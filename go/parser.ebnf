/* "F" series

go.1.1.2.ebnf (original)

ebnf2y -M -o parser.y parser.ebnf		034	028	062
iebnf2y -M -iy 1 -o parser.y parser.ebnf	019	038	057

...............................................................................
Binary_op,Unary_op,Assign_op,Expression,idlist_colas,identifier_list
BuiltinCall,Call,ForClause,[,;][)}],lbr,commchan,chancomm

%left	OROR
%left	ANDAND
%left	'<' '>' EQ GE LE NE
%left	'+' '-' '^' '|'
%left	'%' '&' '*' '/' ANDNOT LSH RSH

...............................................................................
-BuiltinCall,-BuiltinArgs,ArgumentList,TypeLitNoPtr

ebnf2y -M -o parser.y parser.ebnf		034	015	049
iebnf2y -M -iy 1 -o parser.y parser.ebnf	005	014	019

...............................................................................
-OperandName,-TypeName,-QualifiedIdent

%left	OROR
%left	ANDAND
%left	'<' '>' EQ GE LE NE
%left	'+' '-' '^' '|'
%left	'%' '&' '*' '/' ANDNOT LSH RSH

%left	notDot	// Name
%left	'.'

%left	notLParen // Signature
%left	'('

ebnf2y -M -o parser.y parser.ebnf		038	007	045
iebnf2y -M -iy 1 -o parser.y parser.ebnf	006	006	012

...............................................................................
Key,-FieldName,-ElementIndex

ebnf2y -M -o parser.y parser.ebnf		037	006	043
iebnf2y -M -iy 1 -o parser.y parser.ebnf	005	006	011

...............................................................................
Result

ebnf2y -M -o parser.y parser.ebnf		026	006	032
iebnf2y -M -iy 1 -o parser.y parser.ebnf	002	006	008

...............................................................................
-MethodExpr,-ReceiverType

ebnf2y -M -o parser.y parser.ebnf		032	000	032
iebnf2y -M -iy 1 -o parser.y parser.ebnf	000	000	000

...............................................................................
Result

%left	OROR
%left	ANDAND
%left	'<' '>' EQ GE LE NE
%left	'+' '-' '^' '|'
%left	'%' '&' '*' '/' ANDNOT LSH RSH

%left	notDot	// Name
%left	'.'

%left	notPackage
%left	PACKAGE

ebnf2y -M -o parser.y parser.ebnf		031	000	031
iebnf2y -M -iy 1 -o parser.y parser.ebnf	000	000	000

*/

andand		= "&&" .
andnot		= "&^" .
chancomm	= "chan" "<-" .
comm		= "<-".
commchan	= "<-" "chan" .
ddd		= "..." .
dec		= "--" .
eq		= "==" .
ge		= ">=" .
inc		= "++" .
le		= "<=" .
lsh		= "<<" .
ne		= "!=" .
oror		= "||" .
rsh		= ">>" .

add_assign	= "+=" .
and_assign	= "&=" .
mul_assign	= "*=" .
or_assign 	= "|=" .
quo_assign	= "/=" .
rem_assign	= "%=" .
shl_assign	= "<<=" .
shr_assign	= ">>=" .
sub_assign	= "-=" .
xor_assign	= "^=" .
and_not_assign	= "&^=" .

lbr = .
lpar = .

Binary_op = oror
	| andand
	| eq
	| ne
	| "<"
	| le
	| ">"
	| ge
	| "+"
	| "-"
	| "|"
	| "^"
	| "*"
	| "/"
	| "%"
	| lsh
	| rsh
	| "&"
	| andnot .

Unary_op = "+"
	| "-"
	| "!"
	| "^"
	| "*"
	| "&"
	| comm .

Assign_op = "="
	| add_assign
	| and_assign
	| mul_assign
	| or_assign 
	| quo_assign
	| rem_assign
	| shl_assign
	| shr_assign
	| sub_assign
	| xor_assign
	| and_not_assign .

idlist_colas	= . // identifier { "," identifier } colas .
identifier_list = . // FSM/manually enabled in proper contexts.

// ============================================================================

//add_op = "+"
//	| "-"
//	| "|"
//	| "^" .
//assign_op = [ add_op | mul_op ] "=" .

big_u_value = "\\" "U" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit .

//binary_op = "||"
//	| "&&"
//	| rel_op
//	| add_op
//	| mul_op .

byte_value = octal_byte_value | hex_byte_value .
decimal_digit = "0" … "9" .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
decimals = decimal_digit { decimal_digit } .
escaped_char = "\\" (
		  "a"
		| "b"
		| "f"
		| "n"
		| "r"
		| "t"
		| "v"
		| "\\"
		| "'"
		| "\""
	  ) .
exponent = ( "e" | "E" ) [ "+" | "-" ] decimals .
float_lit = decimals "." [ decimals ] [ exponent ]
	| decimals exponent
	| "." decimals [ exponent ] .
hex_byte_value = "\\" "x" hex_digit hex_digit .
hex_digit = "0" … "9"
	| "A" … "F"
	| "a" … "f" .
hex_lit = "0" ( "x" | "X" ) hex_digit { hex_digit } .
identifier = letter { letter | unicode_digit } .
imaginary_lit = ( decimals | float_lit ) "i" .
int_lit = decimal_lit
	| octal_lit
	| hex_lit .
interpreted_string_lit = "\"" { unicode_value | byte_value } "\"" .
letter = unicode_letter | "_" .
little_u_value = "\\" "u" hex_digit hex_digit hex_digit hex_digit .

//mul_op = "*"
//	| "/"
//	| "%"
//	| "<<"
//	| ">>"
//	| "&"
//	| "&^" .

newline = .
octal_byte_value = "\\" octal_digit octal_digit octal_digit .
octal_digit = "0" … "7" .
octal_lit = "0" { octal_digit } .
raw_string_lit = "`" { unicode_char | newline } "`" .

//rel_op = "=="
//	| "!="
//	| "<"
//	| "<="
//	| ">"
//	| ">=" .

rune_lit = "'" ( unicode_value | byte_value ) "'" .
string_lit = raw_string_lit | interpreted_string_lit .

//unary_op = "+"
//	| "-"
//	| "!"
//	| "^"
//	| "*"
//	| "&"
//	| "<-" .

unicode_char = .
unicode_digit = .
unicode_letter = .
unicode_value = unicode_char
	| little_u_value
	| big_u_value
	| escaped_char .

//AnonymousField = [ "*" ] TypeName .
AnonymousField = [ "*" ] Name .

//ArgumentList = ExpressionList [ "..." ] .
//ArgumentList = ExpressionList [ ddd ] .
ArgumentList = [ [ "*" ] TypeLitNoPtr  "," ] ExpressionList [ ddd ] .

ArrayLength = Expression .
ArrayType = "[" ArrayLength "]" ElementType .

//Assignment = ExpressionList assign_op ExpressionList .
Assignment = ExpressionList Assign_op ExpressionList .

BaseType = Type .
BaseTypeName = identifier .
BasicLit = int_lit
	| float_lit
	| imaginary_lit
	| rune_lit
	| string_lit .
Block = "{" StatementList "}" .
BreakStmt = "break" [ Label ] .

//BuiltinArgs = Type [ "," ArgumentList ] //TODO-
//	| ArgumentList .

//BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
//BuiltinCall = identifier "(" [ BuiltinArgs ] ")" . //TODO-

//Call = "(" [ ArgumentList [ "," ] ] ")" .
Call = "(" [ ArgumentList ] ")" .

Channel = Expression .

//ChannelType = (
//		  "chan" [ "<-" ]
//		| "<-" "chan"
//	  ) ElementType .
ChannelType = (
		  "chan"
		| chancomm
		| commchan
	  ) ElementType .

CommCase = "case" ( SendStmt | RecvStmt )
	| "default" .
CommClause = CommCase ":" StatementList .
CompositeLit = LiteralType LiteralValue .
Condition = Expression .

//ConstDecl = "const" (
//		  ConstSpec
//		| "(" { ConstSpec ";" } ")"
//	  ) .
ConstDecl = "const" (
		  ConstSpec
		| "(" [ ConstSpec { ";" ConstSpec } ] ")"
	  ) .

//ConstSpec = IdentifierList [
//		 [ Type ] "=" ExpressionList
//	  ] .
ConstSpec = identifier_list [
		 [ Type ] "=" ExpressionList
	  ] .

ContinueStmt = "continue" [ Label ] .

//Conversion = Type "(" Expression [ "," ] ")" .
//Conversion = Type "(" Expression ")" .
Conversion = CType "(" Expression ")" .

Declaration = ConstDecl
	| TypeDecl
	| VarDecl .
DeferStmt = "defer" Expression .
Element = [ Key ":" ] Value .

//ElementIndex = Expression .

ElementList = Element { "," Element } .
ElementType = Type .
EmptyStmt = .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList
	| "default" .

//ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] lbr { ExprCaseClause } "}" .

//Expression = UnaryExpr
//	| Expression Binary_op UnaryExpr .
Expression = UnaryExpr
	| Expression Binary_op Expression .

ExpressionList = Expression { "," Expression } .
ExpressionStmt = Expression .
FallthroughStmt = "fallthrough" .

//FieldDecl = (
//		  IdentifierList Type
//		| AnonymousField
//	  ) [ Tag ] .
FieldDecl = (
		  identifier_list Type
		| AnonymousField
	  ) [ Tag ] .

//FieldName = identifier .

//ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
ForClause = InitStmt ";" [ Condition ] ";" PostStmt .

//ForStmt = "for" [
//		  Condition
//		| ForClause
//		| RangeClause
//	  ] Block .
ForStmt = "for" [
		  Condition
		| ForClause
		| RangeClause
	  ] lbr StatementList "}" .

Function = Signature FunctionBody .
FunctionBody = Block .
FunctionDecl = "func" FunctionName ( Function | Signature ) .
FunctionLit = "func" Function .
FunctionName = identifier .
FunctionType = "func" Signature .
GoStmt = "go" Expression .
GotoStmt = "goto" Label .

//IdentifierList = identifier { "," identifier } .

//IfStmt = "if" [ SimpleStmt ";" ] Expression Block [
//		 "else" ( IfStmt | Block )
//	  ] .
IfStmt = "if" [ SimpleStmt ";" ] Expression lbr StatementList "}" [
		 "else" ( IfStmt | Block )
	  ] .

//ImportDecl = "import" (
//		  ImportSpec
//		| "(" { ImportSpec ";" } ")"
//	  ) .
ImportDecl = "import" (
		  ImportSpec
		| "(" [ ImportSpec { ";" ImportSpec } ] ")"
	  ) .

ImportPath = string_lit .
ImportSpec = [ "." | PackageName ] ImportPath .

//IncDecStmt = Expression ( "++" | "--" ) .
IncDecStmt = Expression ( inc | dec ) .

Index = "[" Expression "]" .
InitStmt = SimpleStmt .

//InterfaceType = "interface" "{" { MethodSpec ";" } "}" .
InterfaceType = "interface" "{" [ MethodSpec { ";" MethodSpec } ] "}" .

//InterfaceTypeName = TypeName .
InterfaceTypeName = Name .

//Key = FieldName | ElementIndex .
Key = Expression .

KeyType = Type .
Label = identifier .
LabeledStmt = Label ":" Statement .
Literal = BasicLit
	| CompositeLit
	| FunctionLit .

//LiteralType = StructType
//	| ArrayType
//	| "[" "..." "]" ElementType
//	| SliceType
//	| MapType
//	| TypeName .
//LiteralType = StructType
//	| ArrayType
//	| "[" ddd "]" ElementType
//	| SliceType
//	| MapType
//	| TypeName .
LiteralType = StructType
	| ArrayType
	| "[" ddd "]" ElementType
	| SliceType
	| MapType
	| Name .

//LiteralValue = "{" [ ElementList [ "," ] ] "}" .
LiteralValue = "{" [ ElementList ] "}" .

MapType = "map" "[" KeyType "]" ElementType .
MethodDecl = "func" Receiver MethodName ( Function | Signature ) .

//MethodExpr = ReceiverType "." MethodName .

MethodName = identifier .
MethodSpec = MethodName Signature
	| InterfaceTypeName .

//
Name = identifier [ "." identifier ] .

//Operand = Literal
//	| OperandName
//	| MethodExpr
//	| "(" Expression ")" .
//Operand = Literal
//	| Name
//	| MethodExpr
//	| "(" Expression ")" .
Operand = Literal
	| Name
	| "(" Expression ")" .

//OperandName = identifier | QualifiedIdent .

PackageClause = "package" PackageName .
PackageName = identifier .

//ParameterDecl = [ IdentifierList ] [ "..." ] Type .
ParameterDecl = [ identifier_list ] [ ddd ] Type .

ParameterList = ParameterDecl { "," ParameterDecl } .

//Parameters = "(" [ ParameterList [ "," ] ] ")" .
Parameters = "(" [ ParameterList ] ")" .

PointerType = "*" BaseType .
PostStmt = SimpleStmt .
PrimaryExpr = Operand
	| Conversion
	| PrimaryExpr Selector
	| PrimaryExpr Index
	| PrimaryExpr Slice
	| PrimaryExpr TypeAssertion
	| PrimaryExpr Call .

//QualifiedIdent = PackageName "." identifier .

//RangeClause = (
//		  ExpressionList "="
//		| IdentifierList ":="
//	  ) "range" Expression .
RangeClause = (
		  ExpressionList "="
		| idlist_colas
	  ) "range" Expression .

Receiver = "(" [ identifier ] [ "*" ] BaseTypeName ")" .

//ReceiverType = TypeName
//	| "(" "*" TypeName ")"
//	| "(" ReceiverType ")" .
//ReceiverType = Name
//	| "(" "*" Name ")"
//	| "(" ReceiverType ")" .

RecvExpr = Expression .

//RecvStmt = [
//		  ExpressionList "="
//		| IdentifierList ":="
//	  ] RecvExpr .
RecvStmt = [
		  ExpressionList "="
		| idlist_colas
	  ] RecvExpr .

//Result = Parameters | Type .
//Result = Parameters | Name | TypeLit .
Result = RParameters | Name | TypeLit .
RParameters = lpar [ ParameterList ] ")" .

ReturnStmt = "return" [ ExpressionList ] .
SelectStmt = "select" "{" { CommClause } "}" .
Selector = "." identifier .

//SendStmt = Channel "<-" Expression .
SendStmt = Channel comm Expression .

//ShortVarDecl = IdentifierList ":=" ExpressionList .
ShortVarDecl = idlist_colas ExpressionList .

Signature = Parameters [ Result ] .
SimpleStmt = EmptyStmt
	| ExpressionStmt
	| SendStmt
	| IncDecStmt
	| Assignment
	| ShortVarDecl .
Slice = "[" [ Expression ] ":" [ Expression ] "]" .
SliceType = "[" "]" ElementType .
SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
Statement = Declaration
	| LabeledStmt
	| SimpleStmt
	| GoStmt
	| ReturnStmt
	| BreakStmt
	| ContinueStmt
	| GotoStmt
	| FallthroughStmt
	| Block
	| IfStmt
	| SwitchStmt
	| SelectStmt
	| ForStmt
	| DeferStmt .

//StatementList = { Statement ";" } .
StatementList = Statement { ";" Statement } .

//StructType = "struct" "{" { FieldDecl ";" } "}" .
StructType = "struct" "{" [ FieldDecl { ";" FieldDecl } ] "}" .

SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
Tag = string_lit .
TopLevelDecl = Declaration
	| FunctionDecl
	| MethodDecl .

//Type = TypeName
//	| TypeLit
//	| "(" Type ")" .
Type = Name
	| TypeLit
	| "(" Type ")" .
CType = TypeLitNoPtr 
	| "(" [ "*" ] TypeLitNoPtr ")" .

TypeAssertion = "." "(" Type ")" .
TypeCaseClause = TypeSwitchCase ":" StatementList .

//TypeDecl = "type" (
//		  TypeSpec
//		| "(" { TypeSpec ";" } ")"
//	  ) .
TypeDecl = "type" (
		  TypeSpec
		| "(" [ TypeSpec { ";" TypeSpec } ] ")"
	  ) .

TypeList = Type { "," Type } .

//TypeLit = ArrayType
//	| StructType
//	| PointerType
//	| FunctionType
//	| InterfaceType
//	| SliceType
//	| MapType
//	| ChannelType .
TypeLit = TypeLitNoPtr
	| PointerType .
TypeLitNoPtr = ArrayType
	| StructType
	| FunctionType
	| InterfaceType
	| SliceType
	| MapType
	| ChannelType .

//TypeName = identifier | QualifiedIdent .

TypeSpec = identifier Type .
TypeSwitchCase = "case" TypeList
	| "default" .

//TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeSwitchGuard = [ idlist_colas ] PrimaryExpr "." "(" "type" ")" .

TypeSwitchStmt = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .

//UnaryExpr = PrimaryExpr
//	| unary_op UnaryExpr .
UnaryExpr = PrimaryExpr
	| Unary_op UnaryExpr .

Value = Expression | LiteralValue .

//VarDecl = "var" (
//		  VarSpec
//		| "(" { VarSpec ";" } ")"
//	  ) .
VarDecl = "var" (
		  VarSpec
		| "(" [ VarSpec { ";" VarSpec } ] ")"
	  ) .

//VarSpec = IdentifierList (
//		  Type [ "=" ExpressionList ]
//		| "=" ExpressionList
//	  ) .
VarSpec = identifier_list (
		  Type [ "=" ExpressionList ]
		| "=" ExpressionList
	  ) .
