lbr = .
add_asgn = "+=" .
and_asgn = "&=" .
and_not = "&^" .
and_not_asgn = "&^=" .
andand = "&&" .
colas = ":=" .
comm = "<-" .
ddd = "..." .
dec = "--" .
div_asgn = "/=" .
eq = "==" .
gt = ">=" .
inc = "++" .
lsh = "<<" .
lsh_asgn = "<<=" .
lt = "<=" .
mod_asgn = "%=" .
mul_asgn = "*=" .
ne = "!=" .
or_asgn = "|=" .
oror = "||" .
rsh = ">>" .
rsh_asgn = ">>=" .
sub_asgn = "-=" .
xor_asgn = "^=" .

//add_op = "+"
//        | "-"
//        | "|"
//        | "^" .
//assign_op = [ add_op | mul_op ] "=" .
//big_u_value = "\\" "U" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit .
//byte_value = octal_byte_value | hex_byte_value .
//decimal_digit = "0" … "9" .
//decimal_lit = ( "1" … "9" ) { decimal_digit } .
//decimals = decimal_digit { decimal_digit } .
//escaped_char = "\\" (
//                  "a"
//                | "b"
//                | "f"
//                | "n"
//                | "r"
//                | "t"
//                | "v"
//                | "\\"
//                | "'"
//                | "\""
//          ) .
//exponent = ( "e" | "E" ) [ "+" | "-" ] decimals .
//float_lit = decimals "." [ decimals ] [ exponent ]
//        | decimals exponent
//        | "." decimals [ exponent ] .
float_lit = . 
//hex_byte_value = "\\" "x" hex_digit hex_digit .
//hex_digit = "0" … "9"
//        | "A" … "F"
//        | "a" … "f" .
//hex_lit = "0" ( "x" | "X" ) hex_digit { hex_digit } .
//identifier = letter { letter | unicode_digit } .
identifier = .
//imaginary_lit = ( decimals | float_lit ) "i" .
imaginary_lit = .
//int_lit = decimal_lit
//        | octal_lit
//        | hex_lit .
int_lit = .
//interpreted_string_lit = "\"" { unicode_value | byte_value } "\"" .
//letter = unicode_letter | "_" .
//little_u_value = "\\" "u" hex_digit hex_digit hex_digit hex_digit .
//mul_op = "*"
//        | "/"
//        | "%"
//        | "<<"
//        | ">>"
//        | "&"
//        | "&^" .
//newline = .
//octal_byte_value = "\\" octal_digit octal_digit octal_digit .
//octal_digit = "0" … "7" .
//octal_lit = "0" { octal_digit } .
//raw_string_lit = "`" { unicode_char | newline } "`" .
//rel_op = "=="
//        | "!="
//        | "<"
//        | "<="
//        | ">"
//        | ">=" .
//rune_lit = "'" ( unicode_value | byte_value ) "'" .
rune_lit = .
//string_lit = raw_string_lit | interpreted_string_lit .
string_lit = .
//unary_op =
//          "!"
//        | "&"
//        | "*"
//        | "+"
//        | "-"
//        | "<-"
//        | "^"
//        .
//unicode_char = .
//unicode_digit = .
//unicode_letter = .
//unicode_value = unicode_char
//        | little_u_value
//        | big_u_value
//        | escaped_char .

//AnonymousField = [ "*" ] TypeName .
AnonymousField = 
          TypeName
        |
          "*" TypeName
        .
//ArgumentList = ExpressionList [ "..." ] .
ArgumentList = ExpressionList [ ddd ] .
ArrayLength = Expression .
ArrayType = "[" ArrayLength "]" ElementType .
//Assignment = ExpressionList assign_op ExpressionList .
Assignment = ExpressionList (
                       mod_asgn
                     | and_asgn
                     | and_not_asgn
                     | mul_asgn
                     | add_asgn
                     | sub_asgn
                     | div_asgn
                     | lsh_asgn
                     | "="
                     | rsh_asgn
                     | xor_asgn
                     | or_asgn
             ) ExpressionList .
BaseType = Type .
//BaseTypeName = identifier .
BasicLit = int_lit
        | float_lit
        | imaginary_lit
        | rune_lit
        | string_lit .
Block = "{" StatementList "}" .
Block2 = lbr StatementList "}" .
//BreakStmt = "break" [ Label ] .
BreakStmt = "break" [ identifier ] .
BuiltinArgs = Type [ "," ArgumentList ]
        | ArgumentList .
BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
Call = "(" [ ArgumentList [ "," ] ] ")" .
Channel = Expression .
//ChannelType = (
//                  "chan" [ "<-" ]
//                | "<-" "chan"
//          ) ElementType .
ChannelType = (
                  "chan" [ comm ]
                | comm "chan"
          ) ElementType .
CommCase = "case" ( SendStmt | RecvStmt )
        | "default" .
CommClause = CommCase ":" StatementList .
CompositeLit = LiteralType LiteralValue .
Condition = Expression .
//ConstDecl = "const" (
//                  ConstSpec
//                | "(" { ConstSpec ";" } ")"
//          ) .
ConstDecl = "const" (
                  ConstSpec
                | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")"
          ) .
ConstSpec = IdentifierList [
                 [ Type ] "=" ExpressionList
          ] .
//ContinueStmt = "continue" [ Label ] .
ContinueStmt = "continue" [ identifier ] .
Conversion = Type "(" Expression [ "," ] ")" .
Declaration = ConstDecl
        | TypeDecl
        | VarDecl .
DeferStmt = "defer" Expression .
//Element = [ Key ":" ] Value .
//Element = [ Expression ":" ] Value .
Element = 
	  Value 
	| Expression ":" Value 
	.
//ElementIndex = Expression .
ElementList = Element { "," Element } .
ElementType = Type .
//EmptyStmt = .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList
        | "default" .
//ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .

//ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] lbr { ExprCaseClause } "}" .
ExprSwitchStmt =
          "switch" lbr { ExprCaseClause } "}"
        |
          "switch" Expression lbr { ExprCaseClause } "}"
        |
          "switch" SimpleStmt ";" lbr { ExprCaseClause } "}"
        |
          "switch" SimpleStmt ";" Expression lbr { ExprCaseClause } "}"
        .

//Expression = UnaryExpr
//        | Expression binary_op UnaryExpr .
Expression = UnaryExpr
        | Expression (
                    ne // "!="
                  | "%"
                  | "&"
                  | andand // "&&"
                  | and_not // "&^"
                  | "*"
                  | "+"
                  | "-"
                  | "/"
                  | "<"
                  | lsh // "<<"
                  | lt // "<="
                  | eq // "=="
                  | ">"
                  | gt // ">="
                  | rsh // ">>"
                  | "^"
                  | "|"
                  | oror // "||"
          ) UnaryExpr .
ExpressionList = Expression { "," Expression } .
ExpressionStmt = Expression .
FallthroughStmt = "fallthrough" .
FieldDecl = (
                  IdentifierList Type
                | AnonymousField
          ) [ Tag ] .
//FieldName = identifier .
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
//ForStmt = "for" [
//                  Condition
//                | ForClause
//                | RangeClause
//          ] Block .
ForStmt = "for" [
                  Condition
                | ForClause
                | RangeClause
          ] Block2 .
Function = Signature FunctionBody .
FunctionBody = Block .
//FunctionDecl = "func" FunctionName ( Function | Signature ) .
FunctionDecl = "func" identifier ( Function | Signature ) .
FunctionLit = "func" Function .
//FunctionName = identifier .
FunctionType = "func" Signature .
GoStmt = "go" Expression .
//GotoStmt = "goto" Label .
GotoStmt = "goto" identifier .
IdentifierList = identifier { "," identifier } .
//IfStmt = "if" [ SimpleStmt ";" ] Expression Block [
//                 "else" ( IfStmt | Block )
//          ] .
IfStmt =
          "if" Expression Block2 [
                 "else" ( IfStmt | Block )
          ] 
        | 
          "if" SimpleStmt ";" Expression Block2 [
                 "else" ( IfStmt | Block )
          ] 
        .
//ImportDecl = "import" (
//                  ImportSpec
//                | "(" { ImportSpec ";" } ")"
//          ) .
ImportDecl = "import" (
                  ImportSpec
                | "(" [ ImportSpec { ";" ImportSpec } [ ";" ] ] ")"
          ) .
ImportPath = string_lit .
//ImportSpec = [ "." | PackageName ] ImportPath .
ImportSpec = [ "." | identifier ] ImportPath .
//IncDecStmt = Expression ( "++" | "--" ) .
IncDecStmt = Expression ( inc | dec ) .
Index = "[" Expression "]" .
InitStmt = SimpleStmt .
InterfaceType = "interface" "{" { MethodSpec ";" } "}" .
InterfaceTypeName = TypeName .
//Key = FieldName | ElementIndex .
//Key = identifier | ElementIndex .
KeyType = Type .
//Label = identifier .
//LabeledStmt = Label ":" Statement .
LabeledStmt = identifier ":" Statement .
Literal = BasicLit
        | CompositeLit
        | FunctionLit .
//LiteralType = StructType
//        | ArrayType
//        | "[" "..." "]" ElementType
//        | SliceType
//        | MapType
//        | TypeName .
LiteralType = StructType
        | ArrayType
        | "[" ddd "]" ElementType
        | SliceType
        | MapType
        | TypeName .
LiteralValue = "{" [ ElementList [ "," ] ] "}" .
MapType = "map" "[" KeyType "]" ElementType .
//MethodDecl = "func" Receiver MethodName ( Function | Signature ) .
MethodDecl = "func" Receiver identifier ( Function | Signature ) .
//MethodExpr = ReceiverType "." MethodName .
MethodExpr = ReceiverType "." identifier .
//MethodName = identifier .
//MethodSpec = MethodName Signature
//        | InterfaceTypeName .
MethodSpec = identifier Signature
        | InterfaceTypeName .
Operand = Literal
        | OperandName
        | MethodExpr
        | "(" Expression ")" .
OperandName = identifier | QualifiedIdent .
//PackageClause = "package" PackageName .
PackageClause = "package" identifier .
//PackageName = identifier .
//ParameterDecl = [ IdentifierList ] [ "..." ] Type .
//ParameterDecl = [ IdentifierList ] [ ddd ] Type .
ParameterDecl =
          Type
        | identifier Type
        | identifier ddd Type
        | ddd Type
        .
ParameterList = ParameterDecl { "," ParameterDecl } .
Parameters = "(" [ ParameterList [ "," ] ] ")" .
PointerType = "*" BaseType .
PostStmt = SimpleStmt .
PrimaryExpr = Operand
        | Conversion
        | BuiltinCall
        | PrimaryExpr Selector
        | PrimaryExpr Index
        | PrimaryExpr Slice
        | PrimaryExpr TypeAssertion
        | PrimaryExpr Call .
//QualifiedIdent = PackageName "." identifier .
QualifiedIdent = identifier "." identifier .
//RangeClause = (
//                  ExpressionList "="
//                | IdentifierList ":="
//          ) "range" Expression .
RangeClause = (
                  ExpressionList "="
                | IdentifierList colas
          ) "range" Expression .
//Receiver = "(" [ identifier ] [ "*" ] BaseTypeName ")" .
Receiver =
          "(" identifier ")"
        |
          "(" "*" identifier ")"
        |
          "(" identifier identifier ")"
        |
          "(" identifier "*" identifier ")"
        .

ReceiverType = TypeName
        | "(" "*" TypeName ")"
        | "(" ReceiverType ")" .
RecvExpr = Expression .
//RecvStmt = [
//                  ExpressionList "="
//                | IdentifierList ":="
//          ] RecvExpr .
RecvStmt = 
          RecvExpr 
        |
          
           (       ExpressionList "="
                | IdentifierList colas )
           RecvExpr .
Result = Parameters | Type .
ReturnStmt = "return" [ ExpressionList ] .
SelectStmt = "select" "{" { CommClause } "}" .
Selector = "." identifier .
//SendStmt = Channel "<-" Expression .
SendStmt = Channel comm Expression .
//ShortVarDecl = IdentifierList ":=" ExpressionList .
ShortVarDecl = IdentifierList colas ExpressionList .
Signature = Parameters [ Result ] .
//SimpleStmt = EmptyStmt
//        | ExpressionStmt
//        | SendStmt
//        | IncDecStmt
//        | Assignment
//        | ShortVarDecl .
SimpleStmt = ExpressionStmt
           | SendStmt
           | IncDecStmt
           | Assignment
           | ShortVarDecl .
//Slice = "[" (
//                 [ Expression ] ":" [ Expression ]
//          )
//        | (
//                 [ Expression ] ":" Expression ":" Expression
//          ) "]" .
Slice = "["
		[ Expression ] ":" [ Expression [ ":" Expression ] ]
	"]"
	.
SliceType = "[" "]" ElementType .
SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
Statement = Declaration
        | LabeledStmt
        | SimpleStmt
        | GoStmt
        | ReturnStmt
        | BreakStmt
        | ContinueStmt
        | GotoStmt
        | FallthroughStmt
        | Block
        | IfStmt
        | SwitchStmt
        | SelectStmt
        | ForStmt
        | DeferStmt .
//StatementList = { Statement ";" } .
StatementList = [ Statement ] { ";" [ Statement ] } .
StructType = "struct" "{" { FieldDecl ";" } "}" .
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
Tag = string_lit .
TopLevelDecl = Declaration
        | FunctionDecl
        | MethodDecl .
Type = TypeName
        | TypeLit
        | "(" Type ")" .
TypeAssertion = "." "(" Type ")" .
TypeCaseClause = TypeSwitchCase ":" StatementList .
//TypeDecl = "type" (
//                  TypeSpec
//                | "(" { TypeSpec ";" } ")"
//          ) .
TypeDecl = "type" (
                  TypeSpec
                | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")"
          ) .
TypeList = Type { "," Type } .
TypeLit = ArrayType
        | StructType
        | PointerType
        | FunctionType
        | InterfaceType
        | SliceType
        | MapType
        | ChannelType .
TypeName = identifier | QualifiedIdent .
TypeSpec = identifier Type .
TypeSwitchCase = "case" TypeList
        | "default" .
//TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeSwitchGuard = 
          PrimaryExpr "." "(" "type" ")"
        |
          identifier colas PrimaryExpr "." "(" "type" ")"
        .
//TypeSwitchStmt = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchStmt =
          "switch" TypeSwitchGuard lbr { TypeCaseClause } "}"
        |
          "switch" SimpleStmt ";" TypeSwitchGuard lbr { TypeCaseClause } "}"
        .
//UnaryExpr = PrimaryExpr
//        | unary_op UnaryExpr .
UnaryExpr = PrimaryExpr
        | ( "!" | "&" | "*" | "+" | "-" | comm | "^" ) UnaryExpr .
Value = Expression | LiteralValue .
//VarDecl = "var" (
//                  VarSpec
//                | "(" { VarSpec ";" } ")"
//          ) .
VarDecl = "var" (
                  VarSpec
                | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")"
          ) .
VarSpec = IdentifierList (
                  Type [ "=" ExpressionList ]
                | "=" ExpressionList
          ) .
