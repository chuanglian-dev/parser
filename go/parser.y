%{

//TODO Put your favorite license here
		
// yacc source generated by ebnf2y[1]
// at 2014-02-07 21:28:21.052671045 +0100 CET
//
//  $ ebnf2y -o parser.y -pkg parser parser.ebnf
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
// 
//   [1]: http://github.com/cznic/ebnf2y

package parser //TODO real package name

//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"github.com/cznic/strutil"
)

%}

%union {
	item interface{} //TODO insert real field(s)
}

%token	ADD_ASGN
%token	ANDAND
%token	ANDNOT
%token	ANDNOT_ASGN
%token	AND_ASGN
%token	COLAS
%token	COMM
%token	DDD
%token	DEC
%token	DIV_ASGN
%token	EQ
%token	FLOAT_LIT
%token	GE
%token	IDENTIFIER
%token	IMAGINARY_LIT
%token	INC
%token	INT_LIT
%token	LE
%token	LSH
%token	LSH_ASGN
%token	MOD_ASGN
%token	MUL_ASGN
%token	NEQ
%token	OROR
%token	OR_ASGN
%token	RSH
%token	RSH_ASGN
%token	RUNE_LIT
%token	STRING_LIT
%token	SUB_ASGN
%token	XOR_ASGN

%type	<item> 	/*TODO real type(s), if/where applicable */
	ADD_ASGN
	ANDAND
	ANDNOT
	ANDNOT_ASGN
	AND_ASGN
	COLAS
	COMM
	DDD
	DEC
	DIV_ASGN
	EQ
	FLOAT_LIT
	GE
	IDENTIFIER
	IMAGINARY_LIT
	INC
	INT_LIT
	LE
	LSH
	LSH_ASGN
	MOD_ASGN
	MUL_ASGN
	NEQ
	OROR
	OR_ASGN
	RSH
	RSH_ASGN
	RUNE_LIT
	STRING_LIT
	SUB_ASGN
	XOR_ASGN

%token BREAK
%token CASE
%token CHAN
%token CONST
%token CONTINUE
%token DEFAULT
%token DEFER
%token ELSE
%token FALLTHROUGH
%token FOR
%token FUNC
%token GO
%token GOTO
%token IF
%token IMPORT
%token INTERFACE
%token MAP
%token PACKAGE
%token RANGE
%token RETURN
%token SELECT
%token STRUCT
%token SWITCH
%token TYPE
%token VAR

%type	<item> 	/*TODO real type(s), if/where applicable */
	AnonymousField
	ArgumentList
	ArgumentList1
	ArrayLength
	ArrayType
	Assignment
	BaseType
	BaseTypeName
	BasicLit
	Block
	BreakStmt
	BreakStmt1
	BuiltinArgs
	BuiltinArgs1
	BuiltinCall
	BuiltinCall1
	BuiltinCall11
	Call
	Call1
	Call11
	Channel
	ChannelType
	ChannelType1
	ChannelType11
	CommCase
	CommCase1
	CommClause
	CompositeLit
	Condition
	ConstDecl
	ConstDecl1
	ConstDecl11
	ConstSpec
	ConstSpec1
	ConstSpec11
	ContinueStmt
	ContinueStmt1
	Conversion
	Conversion1
	Declaration
	DeferStmt
	Element
	Element1
	ElementIndex
	ElementList
	ElementList1
	ElementType
	ExprCaseClause
	ExprSwitchCase
	ExprSwitchStmt
	ExprSwitchStmt1
	ExprSwitchStmt2
	ExprSwitchStmt3
	ExprSwitchStmt4
	Expression
	Expression1
	ExpressionList
	ExpressionList1
	ExpressionStmt
	Factor
	Factor1
	Factor11
	FallthroughStmt
	FieldDecl
	FieldDecl1
	FieldDecl2
	FieldName
	ForClause
	ForClause1
	ForClause2
	ForClause3
	ForStmt
	ForStmt1
	ForStmt11
	Function
	FunctionBody
	FunctionDecl
	FunctionDecl1
	FunctionLit
	FunctionName
	FunctionType
	GoStmt
	GotoStmt
	IdentifierList
	IdentifierList1
	IfStmt
	IfStmt1
	IfStmt11
	IfStmt2
	IfStmt21
	ImportDecl
	ImportDecl1
	ImportDecl11
	ImportPath
	ImportSpec
	ImportSpec1
	ImportSpec11
	IncDecStmt
	IncDecStmt1
	Index
	InitStmt
	InterfaceType
	InterfaceType1
	InterfaceTypeName
	Key
	KeyType
	Label
	LabeledStmt
	Literal
	LiteralType
	LiteralValue
	LiteralValue1
	LiteralValue11
	MapType
	MethodDecl
	MethodDecl1
	MethodExpr
	MethodName
	MethodSpec
	Operand
	OperandName
	PackageClause
	PackageName
	ParameterDecl
	ParameterDecl1
	ParameterDecl2
	ParameterList
	ParameterList1
	Parameters
	Parameters1
	Parameters11
	PointerType
	PostStmt
	PrimaryExpr
	PrimaryFactor
	PrimaryFactor1
	PrimaryFactor11
	PrimaryTerm
	PrimaryTerm1
	PrimaryTerm11
	QualifiedIdent
	RangeClause
	RangeClause1
	Receiver
	Receiver1
	Receiver2
	ReceiverType
	RecvExpr
	RecvStmt
	RecvStmt1
	RecvStmt11
	Result
	ReturnStmt
	ReturnStmt1
	SelectStmt
	SelectStmt1
	Selector
	SendStmt
	ShortVarDecl
	Signature
	Signature1
	SimpleStmt
	Slice
	Slice1
	Slice11
	Slice12
	Slice2
	Slice21
	SliceType
	SourceFile
	SourceFile1
	SourceFile2
	Start
	Statement
	StatementList
	StatementList1
	StatementList2
	StatementList21
	StructType
	StructType1
	SwitchStmt
	Tag
	Term
	Term1
	TopLevelDecl
	Type
	TypeAssertion
	TypeCaseClause
	TypeDecl
	TypeDecl1
	TypeDecl11
	TypeList
	TypeList1
	TypeLit
	TypeName
	TypeSpec
	TypeSwitchCase
	TypeSwitchGuard
	TypeSwitchGuard1
	TypeSwitchStmt
	TypeSwitchStmt1
	TypeSwitchStmt2
	UnaryExpr
	UnaryExpr1
	UnaryExpr11
	Value
	VarDecl
	VarDecl1
	VarDecl11
	VarSpec
	VarSpec1
	VarSpec11

/*TODO %left, %right, ... declarations */

%start Start

%%

AnonymousField:
	TypeName
	{
		$$ = $1 //TODO 1
	}
|	'*' TypeName
	{
		$$ = []AnonymousField{"*", $2} //TODO 2
	}

ArgumentList:
	ExpressionList ArgumentList1
	{
		$$ = []ArgumentList{$1, $2} //TODO 3
	}

ArgumentList1:
	/* EMPTY */
	{
		$$ = nil //TODO 4
	}
|	DDD
	{
		$$ = $1 //TODO 5
	}

ArrayLength:
	Expression
	{
		$$ = $1 //TODO 6
	}

ArrayType:
	'[' ArrayLength ']' ElementType
	{
		$$ = []ArrayType{"[", $2, "]", $4} //TODO 7
	}

Assignment:
	ExpressionList '=' ExpressionList
	{
		$$ = []Assignment{$1, "=", $3} //TODO 8
	}
|	ExpressionList ADD_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 9
	}
|	ExpressionList AND_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 10
	}
|	ExpressionList ANDNOT_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 11
	}
|	ExpressionList DIV_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 12
	}
|	ExpressionList LSH_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 13
	}
|	ExpressionList MOD_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 14
	}
|	ExpressionList MUL_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 15
	}
|	ExpressionList OR_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 16
	}
|	ExpressionList RSH_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 17
	}
|	ExpressionList SUB_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 18
	}
|	ExpressionList XOR_ASGN ExpressionList
	{
		$$ = []Assignment{$1, $2, $3} //TODO 19
	}

BaseType:
	Type
	{
		$$ = $1 //TODO 20
	}

BaseTypeName:
	IDENTIFIER
	{
		$$ = $1 //TODO 21
	}

BasicLit:
	INT_LIT
	{
		$$ = $1 //TODO 22
	}
|	FLOAT_LIT
	{
		$$ = $1 //TODO 23
	}
|	IMAGINARY_LIT
	{
		$$ = $1 //TODO 24
	}
|	RUNE_LIT
	{
		$$ = $1 //TODO 25
	}
|	STRING_LIT
	{
		$$ = $1 //TODO 26
	}

Block:
	'{' StatementList '}'
	{
		$$ = []Block{"{", $2, "}"} //TODO 27
	}

BreakStmt:
	BREAK BreakStmt1
	{
		$$ = []BreakStmt{"break", $2} //TODO 28
	}

BreakStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 29
	}
|	Label
	{
		$$ = $1 //TODO 30
	}

BuiltinArgs:
	Type BuiltinArgs1
	{
		$$ = []BuiltinArgs{$1, $2} //TODO 31
	}
|	ArgumentList
	{
		$$ = $1 //TODO 32
	}

BuiltinArgs1:
	/* EMPTY */
	{
		$$ = nil //TODO 33
	}
|	',' ArgumentList
	{
		$$ = []BuiltinArgs1{",", $2} //TODO 34
	}

BuiltinCall:
	IDENTIFIER '(' BuiltinCall1 ')'
	{
		$$ = []BuiltinCall{$1, "(", $3, ")"} //TODO 35
	}

BuiltinCall1:
	/* EMPTY */
	{
		$$ = nil //TODO 36
	}
|	BuiltinArgs BuiltinCall11
	{
		$$ = []BuiltinCall1{$1, $2} //TODO 37
	}

BuiltinCall11:
	/* EMPTY */
	{
		$$ = nil //TODO 38
	}
|	','
	{
		$$ = "," //TODO 39
	}

Call:
	'(' Call1 ')'
	{
		$$ = []Call{"(", $2, ")"} //TODO 40
	}

Call1:
	/* EMPTY */
	{
		$$ = nil //TODO 41
	}
|	ArgumentList Call11
	{
		$$ = []Call1{$1, $2} //TODO 42
	}

Call11:
	/* EMPTY */
	{
		$$ = nil //TODO 43
	}
|	','
	{
		$$ = "," //TODO 44
	}

Channel:
	Expression
	{
		$$ = $1 //TODO 45
	}

ChannelType:
	ChannelType1 ElementType
	{
		$$ = []ChannelType{$1, $2} //TODO 46
	}

ChannelType1:
	CHAN ChannelType11
	{
		$$ = []ChannelType1{"chan", $2} //TODO 47
	}
|	COMM CHAN
	{
		$$ = []ChannelType1{$1, "chan"} //TODO 48
	}

ChannelType11:
	/* EMPTY */
	{
		$$ = nil //TODO 49
	}
|	COMM
	{
		$$ = $1 //TODO 50
	}

CommCase:
	CASE CommCase1
	{
		$$ = []CommCase{"case", $2} //TODO 51
	}
|	DEFAULT
	{
		$$ = "default" //TODO 52
	}

CommCase1:
	SendStmt
	{
		$$ = $1 //TODO 53
	}
|	RecvStmt
	{
		$$ = $1 //TODO 54
	}

CommClause:
	CommCase ':' StatementList
	{
		$$ = []CommClause{$1, ":", $3} //TODO 55
	}

CompositeLit:
	LiteralType LiteralValue
	{
		$$ = []CompositeLit{$1, $2} //TODO 56
	}

Condition:
	Expression
	{
		$$ = $1 //TODO 57
	}

ConstDecl:
	CONST ConstDecl1
	{
		$$ = []ConstDecl{"const", $2} //TODO 58
	}

ConstDecl1:
	ConstSpec
	{
		$$ = $1 //TODO 59
	}
|	'(' ConstDecl11 ')'
	{
		$$ = []ConstDecl1{"(", $2, ")"} //TODO 60
	}

ConstDecl11:
	/* EMPTY */
	{
		$$ = []ConstDecl11(nil) //TODO 61
	}
|	ConstDecl11 ConstSpec ';'
	{
		$$ = append($1.([]ConstDecl11), $2, ";") //TODO 62
	}

ConstSpec:
	IdentifierList ConstSpec1
	{
		$$ = []ConstSpec{$1, $2} //TODO 63
	}

ConstSpec1:
	/* EMPTY */
	{
		$$ = nil //TODO 64
	}
|	ConstSpec11 '=' ExpressionList
	{
		$$ = []ConstSpec1{$1, "=", $3} //TODO 65
	}

ConstSpec11:
	/* EMPTY */
	{
		$$ = nil //TODO 66
	}
|	Type
	{
		$$ = $1 //TODO 67
	}

ContinueStmt:
	CONTINUE ContinueStmt1
	{
		$$ = []ContinueStmt{"continue", $2} //TODO 68
	}

ContinueStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 69
	}
|	Label
	{
		$$ = $1 //TODO 70
	}

Conversion:
	Type '(' Expression Conversion1 ')'
	{
		$$ = []Conversion{$1, "(", $3, $4, ")"} //TODO 71
	}

Conversion1:
	/* EMPTY */
	{
		$$ = nil //TODO 72
	}
|	','
	{
		$$ = "," //TODO 73
	}

Declaration:
	ConstDecl
	{
		$$ = $1 //TODO 74
	}
|	TypeDecl
	{
		$$ = $1 //TODO 75
	}
|	VarDecl
	{
		$$ = $1 //TODO 76
	}

DeferStmt:
	DEFER Expression
	{
		$$ = []DeferStmt{"defer", $2} //TODO 77
	}

Element:
	Element1 Value
	{
		$$ = []Element{$1, $2} //TODO 78
	}

Element1:
	/* EMPTY */
	{
		$$ = nil //TODO 79
	}
|	Key ':'
	{
		$$ = []Element1{$1, ":"} //TODO 80
	}

ElementIndex:
	Expression
	{
		$$ = $1 //TODO 81
	}

ElementList:
	Element ElementList1
	{
		$$ = []ElementList{$1, $2} //TODO 82
	}

ElementList1:
	/* EMPTY */
	{
		$$ = []ElementList1(nil) //TODO 83
	}
|	ElementList1 ',' Element
	{
		$$ = append($1.([]ElementList1), ",", $3) //TODO 84
	}

ElementType:
	Type
	{
		$$ = $1 //TODO 85
	}

ExprCaseClause:
	ExprSwitchCase ':' StatementList
	{
		$$ = []ExprCaseClause{$1, ":", $3} //TODO 86
	}

ExprSwitchCase:
	CASE ExpressionList
	{
		$$ = []ExprSwitchCase{"case", $2} //TODO 87
	}
|	DEFAULT
	{
		$$ = "default" //TODO 88
	}

ExprSwitchStmt:
	SWITCH '{' ExprSwitchStmt1 '}'
	{
		$$ = []ExprSwitchStmt{"switch", "{", $3, "}"} //TODO 89
	}
|	SWITCH Expression '{' ExprSwitchStmt2 '}'
	{
		$$ = []ExprSwitchStmt{"switch", $2, "{", $4, "}"} //TODO 90
	}
|	SWITCH SimpleStmt ';' '{' ExprSwitchStmt3 '}'
	{
		$$ = []ExprSwitchStmt{"switch", $2, ";", "{", $5, "}"} //TODO 91
	}
|	SWITCH SimpleStmt ';' Expression '{' ExprSwitchStmt4 '}'
	{
		$$ = []ExprSwitchStmt{"switch", $2, ";", $4, "{", $6, "}"} //TODO 92
	}

ExprSwitchStmt1:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt1(nil) //TODO 93
	}
|	ExprSwitchStmt1 ExprCaseClause
	{
		$$ = append($1.([]ExprSwitchStmt1), $2) //TODO 94
	}

ExprSwitchStmt2:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt2(nil) //TODO 95
	}
|	ExprSwitchStmt2 ExprCaseClause
	{
		$$ = append($1.([]ExprSwitchStmt2), $2) //TODO 96
	}

ExprSwitchStmt3:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt3(nil) //TODO 97
	}
|	ExprSwitchStmt3 ExprCaseClause
	{
		$$ = append($1.([]ExprSwitchStmt3), $2) //TODO 98
	}

ExprSwitchStmt4:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt4(nil) //TODO 99
	}
|	ExprSwitchStmt4 ExprCaseClause
	{
		$$ = append($1.([]ExprSwitchStmt4), $2) //TODO 100
	}

Expression:
	Term Expression1
	{
		$$ = []Expression{$1, $2} //TODO 101
	}

Expression1:
	/* EMPTY */
	{
		$$ = []Expression1(nil) //TODO 102
	}
|	Expression1 OROR Term
	{
		$$ = append($1.([]Expression1), $2, $3) //TODO 103
	}

ExpressionList:
	Expression ExpressionList1
	{
		$$ = []ExpressionList{$1, $2} //TODO 104
	}

ExpressionList1:
	/* EMPTY */
	{
		$$ = []ExpressionList1(nil) //TODO 105
	}
|	ExpressionList1 ',' Expression
	{
		$$ = append($1.([]ExpressionList1), ",", $3) //TODO 106
	}

ExpressionStmt:
	Expression
	{
		$$ = $1 //TODO 107
	}

Factor:
	PrimaryFactor Factor1
	{
		$$ = []Factor{$1, $2} //TODO 108
	}

Factor1:
	/* EMPTY */
	{
		$$ = []Factor1(nil) //TODO 109
	}
|	Factor1 Factor11 PrimaryFactor
	{
		$$ = append($1.([]Factor1), $2, $3) //TODO 110
	}

Factor11:
	GE
	{
		$$ = $1 //TODO 111
	}
|	'>'
	{
		$$ = ">" //TODO 112
	}
|	LE
	{
		$$ = $1 //TODO 113
	}
|	'<'
	{
		$$ = "<" //TODO 114
	}
|	NEQ
	{
		$$ = $1 //TODO 115
	}
|	EQ
	{
		$$ = $1 //TODO 116
	}

FallthroughStmt:
	FALLTHROUGH
	{
		$$ = "fallthrough" //TODO 117
	}

FieldDecl:
	FieldDecl1 FieldDecl2
	{
		$$ = []FieldDecl{$1, $2} //TODO 118
	}

FieldDecl1:
	IdentifierList Type
	{
		$$ = []FieldDecl1{$1, $2} //TODO 119
	}
|	AnonymousField
	{
		$$ = $1 //TODO 120
	}

FieldDecl2:
	/* EMPTY */
	{
		$$ = nil //TODO 121
	}
|	Tag
	{
		$$ = $1 //TODO 122
	}

FieldName:
	IDENTIFIER
	{
		$$ = $1 //TODO 123
	}

ForClause:
	ForClause1 ';' ForClause2 ';' ForClause3
	{
		$$ = []ForClause{$1, ";", $3, ";", $5} //TODO 124
	}

ForClause1:
	/* EMPTY */
	{
		$$ = nil //TODO 125
	}
|	InitStmt
	{
		$$ = $1 //TODO 126
	}

ForClause2:
	/* EMPTY */
	{
		$$ = nil //TODO 127
	}
|	Condition
	{
		$$ = $1 //TODO 128
	}

ForClause3:
	/* EMPTY */
	{
		$$ = nil //TODO 129
	}
|	PostStmt
	{
		$$ = $1 //TODO 130
	}

ForStmt:
	FOR ForStmt1 Block
	{
		$$ = []ForStmt{"for", $2, $3} //TODO 131
	}

ForStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 132
	}
|	ForStmt11
	{
		$$ = $1 //TODO 133
	}

ForStmt11:
	Condition
	{
		$$ = $1 //TODO 134
	}
|	ForClause
	{
		$$ = $1 //TODO 135
	}
|	RangeClause
	{
		$$ = $1 //TODO 136
	}

Function:
	Signature FunctionBody
	{
		$$ = []Function{$1, $2} //TODO 137
	}

FunctionBody:
	Block
	{
		$$ = $1 //TODO 138
	}

FunctionDecl:
	FUNC FunctionName FunctionDecl1
	{
		$$ = []FunctionDecl{"func", $2, $3} //TODO 139
	}

FunctionDecl1:
	Function
	{
		$$ = $1 //TODO 140
	}
|	Signature
	{
		$$ = $1 //TODO 141
	}

FunctionLit:
	FUNC Function
	{
		$$ = []FunctionLit{"func", $2} //TODO 142
	}

FunctionName:
	IDENTIFIER
	{
		$$ = $1 //TODO 143
	}

FunctionType:
	FUNC Signature
	{
		$$ = []FunctionType{"func", $2} //TODO 144
	}

GoStmt:
	GO Expression
	{
		$$ = []GoStmt{"go", $2} //TODO 145
	}

GotoStmt:
	GOTO Label
	{
		$$ = []GotoStmt{"goto", $2} //TODO 146
	}

IdentifierList:
	IDENTIFIER IdentifierList1
	{
		$$ = []IdentifierList{$1, $2} //TODO 147
	}

IdentifierList1:
	/* EMPTY */
	{
		$$ = []IdentifierList1(nil) //TODO 148
	}
|	IdentifierList1 ',' IDENTIFIER
	{
		$$ = append($1.([]IdentifierList1), ",", $3) //TODO 149
	}

IfStmt:
	IF Expression Block IfStmt1
	{
		$$ = []IfStmt{"if", $2, $3, $4} //TODO 150
	}
|	IF SimpleStmt ';' Expression Block IfStmt2
	{
		$$ = []IfStmt{"if", $2, ";", $4, $5, $6} //TODO 151
	}

IfStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 152
	}
|	ELSE IfStmt11
	{
		$$ = []IfStmt1{"else", $2} //TODO 153
	}

IfStmt11:
	IfStmt
	{
		$$ = $1 //TODO 154
	}
|	Block
	{
		$$ = $1 //TODO 155
	}

IfStmt2:
	/* EMPTY */
	{
		$$ = nil //TODO 156
	}
|	ELSE IfStmt21
	{
		$$ = []IfStmt2{"else", $2} //TODO 157
	}

IfStmt21:
	IfStmt
	{
		$$ = $1 //TODO 158
	}
|	Block
	{
		$$ = $1 //TODO 159
	}

ImportDecl:
	IMPORT ImportDecl1
	{
		$$ = []ImportDecl{"import", $2} //TODO 160
	}

ImportDecl1:
	ImportSpec
	{
		$$ = $1 //TODO 161
	}
|	'(' ImportDecl11 ')'
	{
		$$ = []ImportDecl1{"(", $2, ")"} //TODO 162
	}

ImportDecl11:
	/* EMPTY */
	{
		$$ = []ImportDecl11(nil) //TODO 163
	}
|	ImportDecl11 ImportSpec ';'
	{
		$$ = append($1.([]ImportDecl11), $2, ";") //TODO 164
	}

ImportPath:
	STRING_LIT
	{
		$$ = $1 //TODO 165
	}

ImportSpec:
	ImportSpec1 ImportPath
	{
		$$ = []ImportSpec{$1, $2} //TODO 166
	}

ImportSpec1:
	/* EMPTY */
	{
		$$ = nil //TODO 167
	}
|	ImportSpec11
	{
		$$ = $1 //TODO 168
	}

ImportSpec11:
	'.'
	{
		$$ = "." //TODO 169
	}
|	PackageName
	{
		$$ = $1 //TODO 170
	}

IncDecStmt:
	Expression IncDecStmt1
	{
		$$ = []IncDecStmt{$1, $2} //TODO 171
	}

IncDecStmt1:
	INC
	{
		$$ = $1 //TODO 172
	}
|	DEC
	{
		$$ = $1 //TODO 173
	}

Index:
	'[' Expression ']'
	{
		$$ = []Index{"[", $2, "]"} //TODO 174
	}

InitStmt:
	SimpleStmt
	{
		$$ = $1 //TODO 175
	}

InterfaceType:
	INTERFACE '{' InterfaceType1 '}'
	{
		$$ = []InterfaceType{"interface", "{", $3, "}"} //TODO 176
	}

InterfaceType1:
	/* EMPTY */
	{
		$$ = []InterfaceType1(nil) //TODO 177
	}
|	InterfaceType1 MethodSpec ';'
	{
		$$ = append($1.([]InterfaceType1), $2, ";") //TODO 178
	}

InterfaceTypeName:
	TypeName
	{
		$$ = $1 //TODO 179
	}

Key:
	FieldName
	{
		$$ = $1 //TODO 180
	}
|	ElementIndex
	{
		$$ = $1 //TODO 181
	}

KeyType:
	Type
	{
		$$ = $1 //TODO 182
	}

Label:
	IDENTIFIER
	{
		$$ = $1 //TODO 183
	}

LabeledStmt:
	Label ':' Statement
	{
		$$ = []LabeledStmt{$1, ":", $3} //TODO 184
	}

Literal:
	BasicLit
	{
		$$ = $1 //TODO 185
	}
|	CompositeLit
	{
		$$ = $1 //TODO 186
	}
|	FunctionLit
	{
		$$ = $1 //TODO 187
	}

LiteralType:
	StructType
	{
		$$ = $1 //TODO 188
	}
|	ArrayType
	{
		$$ = $1 //TODO 189
	}
|	'[' DDD ']' ElementType
	{
		$$ = []LiteralType{"[", $2, "]", $4} //TODO 190
	}
|	SliceType
	{
		$$ = $1 //TODO 191
	}
|	MapType
	{
		$$ = $1 //TODO 192
	}
|	TypeName
	{
		$$ = $1 //TODO 193
	}

LiteralValue:
	'{' LiteralValue1 '}'
	{
		$$ = []LiteralValue{"{", $2, "}"} //TODO 194
	}

LiteralValue1:
	/* EMPTY */
	{
		$$ = nil //TODO 195
	}
|	ElementList LiteralValue11
	{
		$$ = []LiteralValue1{$1, $2} //TODO 196
	}

LiteralValue11:
	/* EMPTY */
	{
		$$ = nil //TODO 197
	}
|	','
	{
		$$ = "," //TODO 198
	}

MapType:
	MAP '[' KeyType ']' ElementType
	{
		$$ = []MapType{"map", "[", $3, "]", $5} //TODO 199
	}

MethodDecl:
	FUNC Receiver MethodName MethodDecl1
	{
		$$ = []MethodDecl{"func", $2, $3, $4} //TODO 200
	}

MethodDecl1:
	Function
	{
		$$ = $1 //TODO 201
	}
|	Signature
	{
		$$ = $1 //TODO 202
	}

MethodExpr:
	ReceiverType '.' MethodName
	{
		$$ = []MethodExpr{$1, ".", $3} //TODO 203
	}

MethodName:
	IDENTIFIER
	{
		$$ = $1 //TODO 204
	}

MethodSpec:
	MethodName Signature
	{
		$$ = []MethodSpec{$1, $2} //TODO 205
	}
|	InterfaceTypeName
	{
		$$ = $1 //TODO 206
	}

Operand:
	Literal
	{
		$$ = $1 //TODO 207
	}
|	OperandName
	{
		$$ = $1 //TODO 208
	}
|	MethodExpr
	{
		$$ = $1 //TODO 209
	}
|	'(' Expression ')'
	{
		$$ = []Operand{"(", $2, ")"} //TODO 210
	}

OperandName:
	IDENTIFIER
	{
		$$ = $1 //TODO 211
	}
|	QualifiedIdent
	{
		$$ = $1 //TODO 212
	}

PackageClause:
	PACKAGE PackageName
	{
		$$ = []PackageClause{"package", $2} //TODO 213
	}

PackageName:
	IDENTIFIER
	{
		$$ = $1 //TODO 214
	}

ParameterDecl:
	ParameterDecl1 ParameterDecl2 Type
	{
		$$ = []ParameterDecl{$1, $2, $3} //TODO 215
	}

ParameterDecl1:
	/* EMPTY */
	{
		$$ = nil //TODO 216
	}
|	IdentifierList
	{
		$$ = $1 //TODO 217
	}

ParameterDecl2:
	/* EMPTY */
	{
		$$ = nil //TODO 218
	}
|	DDD
	{
		$$ = $1 //TODO 219
	}

ParameterList:
	ParameterDecl ParameterList1
	{
		$$ = []ParameterList{$1, $2} //TODO 220
	}

ParameterList1:
	/* EMPTY */
	{
		$$ = []ParameterList1(nil) //TODO 221
	}
|	ParameterList1 ',' ParameterDecl
	{
		$$ = append($1.([]ParameterList1), ",", $3) //TODO 222
	}

Parameters:
	'(' Parameters1 ')'
	{
		$$ = []Parameters{"(", $2, ")"} //TODO 223
	}

Parameters1:
	/* EMPTY */
	{
		$$ = nil //TODO 224
	}
|	ParameterList Parameters11
	{
		$$ = []Parameters1{$1, $2} //TODO 225
	}

Parameters11:
	/* EMPTY */
	{
		$$ = nil //TODO 226
	}
|	','
	{
		$$ = "," //TODO 227
	}

PointerType:
	'*' BaseType
	{
		$$ = []PointerType{"*", $2} //TODO 228
	}

PostStmt:
	SimpleStmt
	{
		$$ = $1 //TODO 229
	}

PrimaryExpr:
	Operand
	{
		$$ = $1 //TODO 230
	}
|	Conversion
	{
		$$ = $1 //TODO 231
	}
|	BuiltinCall
	{
		$$ = $1 //TODO 232
	}
|	PrimaryExpr Selector
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 233
	}
|	PrimaryExpr Index
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 234
	}
|	PrimaryExpr Slice
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 235
	}
|	PrimaryExpr TypeAssertion
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 236
	}
|	PrimaryExpr Call
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 237
	}

PrimaryFactor:
	PrimaryTerm PrimaryFactor1
	{
		$$ = []PrimaryFactor{$1, $2} //TODO 238
	}

PrimaryFactor1:
	/* EMPTY */
	{
		$$ = []PrimaryFactor1(nil) //TODO 239
	}
|	PrimaryFactor1 PrimaryFactor11 PrimaryTerm
	{
		$$ = append($1.([]PrimaryFactor1), $2, $3) //TODO 240
	}

PrimaryFactor11:
	'^'
	{
		$$ = "^" //TODO 241
	}
|	'|'
	{
		$$ = "|" //TODO 242
	}
|	'-'
	{
		$$ = "-" //TODO 243
	}
|	'+'
	{
		$$ = "+" //TODO 244
	}

PrimaryTerm:
	UnaryExpr PrimaryTerm1
	{
		$$ = []PrimaryTerm{$1, $2} //TODO 245
	}

PrimaryTerm1:
	/* EMPTY */
	{
		$$ = []PrimaryTerm1(nil) //TODO 246
	}
|	PrimaryTerm1 PrimaryTerm11 UnaryExpr
	{
		$$ = append($1.([]PrimaryTerm1), $2, $3) //TODO 247
	}

PrimaryTerm11:
	ANDNOT
	{
		$$ = $1 //TODO 248
	}
|	'&'
	{
		$$ = "&" //TODO 249
	}
|	LSH
	{
		$$ = $1 //TODO 250
	}
|	RSH
	{
		$$ = $1 //TODO 251
	}
|	'%'
	{
		$$ = "%" //TODO 252
	}
|	'/'
	{
		$$ = "/" //TODO 253
	}
|	'*'
	{
		$$ = "*" //TODO 254
	}

QualifiedIdent:
	PackageName '.' IDENTIFIER
	{
		$$ = []QualifiedIdent{$1, ".", $3} //TODO 255
	}

RangeClause:
	RangeClause1 RANGE Expression
	{
		$$ = []RangeClause{$1, "range", $3} //TODO 256
	}

RangeClause1:
	ExpressionList '='
	{
		$$ = []RangeClause1{$1, "="} //TODO 257
	}
|	IdentifierList COLAS
	{
		$$ = []RangeClause1{$1, $2} //TODO 258
	}

Receiver:
	'(' Receiver1 Receiver2 BaseTypeName ')'
	{
		$$ = []Receiver{"(", $2, $3, $4, ")"} //TODO 259
	}

Receiver1:
	/* EMPTY */
	{
		$$ = nil //TODO 260
	}
|	IDENTIFIER
	{
		$$ = $1 //TODO 261
	}

Receiver2:
	/* EMPTY */
	{
		$$ = nil //TODO 262
	}
|	'*'
	{
		$$ = "*" //TODO 263
	}

ReceiverType:
	TypeName
	{
		$$ = $1 //TODO 264
	}
|	'(' '*' TypeName ')'
	{
		$$ = []ReceiverType{"(", "*", $3, ")"} //TODO 265
	}
|	'(' ReceiverType ')'
	{
		$$ = []ReceiverType{"(", $2, ")"} //TODO 266
	}

RecvExpr:
	Expression
	{
		$$ = $1 //TODO 267
	}

RecvStmt:
	RecvStmt1 RecvExpr
	{
		$$ = []RecvStmt{$1, $2} //TODO 268
	}

RecvStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 269
	}
|	RecvStmt11
	{
		$$ = $1 //TODO 270
	}

RecvStmt11:
	ExpressionList '='
	{
		$$ = []RecvStmt11{$1, "="} //TODO 271
	}
|	IdentifierList COLAS
	{
		$$ = []RecvStmt11{$1, $2} //TODO 272
	}

Result:
	Parameters
	{
		$$ = $1 //TODO 273
	}
|	Type
	{
		$$ = $1 //TODO 274
	}

ReturnStmt:
	RETURN ReturnStmt1
	{
		$$ = []ReturnStmt{"return", $2} //TODO 275
	}

ReturnStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 276
	}
|	ExpressionList
	{
		$$ = $1 //TODO 277
	}

SelectStmt:
	SELECT '{' SelectStmt1 '}'
	{
		$$ = []SelectStmt{"select", "{", $3, "}"} //TODO 278
	}

SelectStmt1:
	/* EMPTY */
	{
		$$ = []SelectStmt1(nil) //TODO 279
	}
|	SelectStmt1 CommClause
	{
		$$ = append($1.([]SelectStmt1), $2) //TODO 280
	}

Selector:
	'.' IDENTIFIER
	{
		$$ = []Selector{".", $2} //TODO 281
	}

SendStmt:
	Channel COMM Expression
	{
		$$ = []SendStmt{$1, $2, $3} //TODO 282
	}

ShortVarDecl:
	IdentifierList COLAS ExpressionList
	{
		$$ = []ShortVarDecl{$1, $2, $3} //TODO 283
	}

Signature:
	Parameters Signature1
	{
		$$ = []Signature{$1, $2} //TODO 284
	}

Signature1:
	/* EMPTY */
	{
		$$ = nil //TODO 285
	}
|	Result
	{
		$$ = $1 //TODO 286
	}

SimpleStmt:
	Assignment
	{
		$$ = $1 //TODO 287
	}
|	ExpressionStmt
	{
		$$ = $1 //TODO 288
	}
|	IncDecStmt
	{
		$$ = $1 //TODO 289
	}
|	SendStmt
	{
		$$ = $1 //TODO 290
	}
|	ShortVarDecl
	{
		$$ = $1 //TODO 291
	}

Slice:
	'[' Slice1
	{
		$$ = []Slice{"[", $2} //TODO 292
	}
|	Slice2 ']'
	{
		$$ = []Slice{$1, "]"} //TODO 293
	}

Slice1:
	Slice11 ':' Slice12
	{
		$$ = []Slice1{$1, ":", $3} //TODO 294
	}

Slice11:
	/* EMPTY */
	{
		$$ = nil //TODO 295
	}
|	Expression
	{
		$$ = $1 //TODO 296
	}

Slice12:
	/* EMPTY */
	{
		$$ = nil //TODO 297
	}
|	Expression
	{
		$$ = $1 //TODO 298
	}

Slice2:
	Slice21 ':' Expression ':' Expression
	{
		$$ = []Slice2{$1, ":", $3, ":", $5} //TODO 299
	}

Slice21:
	/* EMPTY */
	{
		$$ = nil //TODO 300
	}
|	Expression
	{
		$$ = $1 //TODO 301
	}

SliceType:
	'[' ']' ElementType
	{
		$$ = []SliceType{"[", "]", $3} //TODO 302
	}

SourceFile:
	PackageClause ';' SourceFile1 SourceFile2
	{
		$$ = []SourceFile{$1, ";", $3, $4} //TODO 303
	}

SourceFile1:
	/* EMPTY */
	{
		$$ = []SourceFile1(nil) //TODO 304
	}
|	SourceFile1 ImportDecl ';'
	{
		$$ = append($1.([]SourceFile1), $2, ";") //TODO 305
	}

SourceFile2:
	/* EMPTY */
	{
		$$ = []SourceFile2(nil) //TODO 306
	}
|	SourceFile2 TopLevelDecl ';'
	{
		$$ = append($1.([]SourceFile2), $2, ";") //TODO 307
	}

Start:
	SourceFile
	{
		_parserResult = $1 //TODO 308
	}

Statement:
	Declaration
	{
		$$ = $1 //TODO 309
	}
|	LabeledStmt
	{
		$$ = $1 //TODO 310
	}
|	SimpleStmt
	{
		$$ = $1 //TODO 311
	}
|	GoStmt
	{
		$$ = $1 //TODO 312
	}
|	ReturnStmt
	{
		$$ = $1 //TODO 313
	}
|	BreakStmt
	{
		$$ = $1 //TODO 314
	}
|	ContinueStmt
	{
		$$ = $1 //TODO 315
	}
|	GotoStmt
	{
		$$ = $1 //TODO 316
	}
|	FallthroughStmt
	{
		$$ = $1 //TODO 317
	}
|	Block
	{
		$$ = $1 //TODO 318
	}
|	IfStmt
	{
		$$ = $1 //TODO 319
	}
|	SwitchStmt
	{
		$$ = $1 //TODO 320
	}
|	SelectStmt
	{
		$$ = $1 //TODO 321
	}
|	ForStmt
	{
		$$ = $1 //TODO 322
	}
|	DeferStmt
	{
		$$ = $1 //TODO 323
	}

StatementList:
	StatementList1 StatementList2
	{
		$$ = []StatementList{$1, $2} //TODO 324
	}

StatementList1:
	/* EMPTY */
	{
		$$ = nil //TODO 325
	}
|	Statement
	{
		$$ = $1 //TODO 326
	}

StatementList2:
	/* EMPTY */
	{
		$$ = []StatementList2(nil) //TODO 327
	}
|	StatementList2 ';' StatementList21
	{
		$$ = append($1.([]StatementList2), ";", $3) //TODO 328
	}

StatementList21:
	/* EMPTY */
	{
		$$ = nil //TODO 329
	}
|	Statement
	{
		$$ = $1 //TODO 330
	}

StructType:
	STRUCT '{' StructType1 '}'
	{
		$$ = []StructType{"struct", "{", $3, "}"} //TODO 331
	}

StructType1:
	/* EMPTY */
	{
		$$ = []StructType1(nil) //TODO 332
	}
|	StructType1 FieldDecl ';'
	{
		$$ = append($1.([]StructType1), $2, ";") //TODO 333
	}

SwitchStmt:
	ExprSwitchStmt
	{
		$$ = $1 //TODO 334
	}
|	TypeSwitchStmt
	{
		$$ = $1 //TODO 335
	}

Tag:
	STRING_LIT
	{
		$$ = $1 //TODO 336
	}

Term:
	Factor Term1
	{
		$$ = []Term{$1, $2} //TODO 337
	}

Term1:
	/* EMPTY */
	{
		$$ = []Term1(nil) //TODO 338
	}
|	Term1 ANDAND Factor
	{
		$$ = append($1.([]Term1), $2, $3) //TODO 339
	}

TopLevelDecl:
	Declaration
	{
		$$ = $1 //TODO 340
	}
|	FunctionDecl
	{
		$$ = $1 //TODO 341
	}
|	MethodDecl
	{
		$$ = $1 //TODO 342
	}

Type:
	TypeName
	{
		$$ = $1 //TODO 343
	}
|	TypeLit
	{
		$$ = $1 //TODO 344
	}
|	'(' Type ')'
	{
		$$ = []Type{"(", $2, ")"} //TODO 345
	}

TypeAssertion:
	'.' '(' Type ')'
	{
		$$ = []TypeAssertion{".", "(", $3, ")"} //TODO 346
	}

TypeCaseClause:
	TypeSwitchCase ':' StatementList
	{
		$$ = []TypeCaseClause{$1, ":", $3} //TODO 347
	}

TypeDecl:
	TYPE TypeDecl1
	{
		$$ = []TypeDecl{"type", $2} //TODO 348
	}

TypeDecl1:
	TypeSpec
	{
		$$ = $1 //TODO 349
	}
|	'(' TypeDecl11 ')'
	{
		$$ = []TypeDecl1{"(", $2, ")"} //TODO 350
	}

TypeDecl11:
	/* EMPTY */
	{
		$$ = []TypeDecl11(nil) //TODO 351
	}
|	TypeDecl11 TypeSpec ';'
	{
		$$ = append($1.([]TypeDecl11), $2, ";") //TODO 352
	}

TypeList:
	Type TypeList1
	{
		$$ = []TypeList{$1, $2} //TODO 353
	}

TypeList1:
	/* EMPTY */
	{
		$$ = []TypeList1(nil) //TODO 354
	}
|	TypeList1 ',' Type
	{
		$$ = append($1.([]TypeList1), ",", $3) //TODO 355
	}

TypeLit:
	ArrayType
	{
		$$ = $1 //TODO 356
	}
|	StructType
	{
		$$ = $1 //TODO 357
	}
|	PointerType
	{
		$$ = $1 //TODO 358
	}
|	FunctionType
	{
		$$ = $1 //TODO 359
	}
|	InterfaceType
	{
		$$ = $1 //TODO 360
	}
|	SliceType
	{
		$$ = $1 //TODO 361
	}
|	MapType
	{
		$$ = $1 //TODO 362
	}
|	ChannelType
	{
		$$ = $1 //TODO 363
	}

TypeName:
	IDENTIFIER
	{
		$$ = $1 //TODO 364
	}
|	QualifiedIdent
	{
		$$ = $1 //TODO 365
	}

TypeSpec:
	IDENTIFIER Type
	{
		$$ = []TypeSpec{$1, $2} //TODO 366
	}

TypeSwitchCase:
	CASE TypeList
	{
		$$ = []TypeSwitchCase{"case", $2} //TODO 367
	}
|	DEFAULT
	{
		$$ = "default" //TODO 368
	}

TypeSwitchGuard:
	TypeSwitchGuard1 PrimaryExpr '.' '(' TYPE ')'
	{
		$$ = []TypeSwitchGuard{$1, $2, ".", "(", "type", ")"} //TODO 369
	}

TypeSwitchGuard1:
	/* EMPTY */
	{
		$$ = nil //TODO 370
	}
|	IDENTIFIER COLAS
	{
		$$ = []TypeSwitchGuard1{$1, $2} //TODO 371
	}

TypeSwitchStmt:
	SWITCH TypeSwitchGuard '{' TypeSwitchStmt1 '}'
	{
		$$ = []TypeSwitchStmt{"switch", $2, "{", $4, "}"} //TODO 372
	}
|	SWITCH SimpleStmt ';' TypeSwitchGuard '{' TypeSwitchStmt2 '}'
	{
		$$ = []TypeSwitchStmt{"switch", $2, ";", $4, "{", $6, "}"} //TODO 373
	}

TypeSwitchStmt1:
	/* EMPTY */
	{
		$$ = []TypeSwitchStmt1(nil) //TODO 374
	}
|	TypeSwitchStmt1 TypeCaseClause
	{
		$$ = append($1.([]TypeSwitchStmt1), $2) //TODO 375
	}

TypeSwitchStmt2:
	/* EMPTY */
	{
		$$ = []TypeSwitchStmt2(nil) //TODO 376
	}
|	TypeSwitchStmt2 TypeCaseClause
	{
		$$ = append($1.([]TypeSwitchStmt2), $2) //TODO 377
	}

UnaryExpr:
	UnaryExpr1 PrimaryExpr
	{
		$$ = []UnaryExpr{$1, $2} //TODO 378
	}

UnaryExpr1:
	/* EMPTY */
	{
		$$ = nil //TODO 379
	}
|	UnaryExpr11
	{
		$$ = $1 //TODO 380
	}

UnaryExpr11:
	'^'
	{
		$$ = "^" //TODO 381
	}
|	'!'
	{
		$$ = "!" //TODO 382
	}
|	'-'
	{
		$$ = "-" //TODO 383
	}
|	'+'
	{
		$$ = "+" //TODO 384
	}

Value:
	Expression
	{
		$$ = $1 //TODO 385
	}
|	LiteralValue
	{
		$$ = $1 //TODO 386
	}

VarDecl:
	VAR VarDecl1
	{
		$$ = []VarDecl{"var", $2} //TODO 387
	}

VarDecl1:
	VarSpec
	{
		$$ = $1 //TODO 388
	}
|	'(' VarDecl11 ')'
	{
		$$ = []VarDecl1{"(", $2, ")"} //TODO 389
	}

VarDecl11:
	/* EMPTY */
	{
		$$ = []VarDecl11(nil) //TODO 390
	}
|	VarDecl11 VarSpec ';'
	{
		$$ = append($1.([]VarDecl11), $2, ";") //TODO 391
	}

VarSpec:
	IdentifierList VarSpec1
	{
		$$ = []VarSpec{$1, $2} //TODO 392
	}

VarSpec1:
	Type VarSpec11
	{
		$$ = []VarSpec1{$1, $2} //TODO 393
	}
|	'=' ExpressionList
	{
		$$ = []VarSpec1{"=", $2} //TODO 394
	}

VarSpec11:
	/* EMPTY */
	{
		$$ = nil //TODO 395
	}
|	'=' ExpressionList
	{
		$$ = []VarSpec11{"=", $2} //TODO 396
	}

%%

//TODO remove demo stuff below

var _parserResult interface{}

type (
	AnonymousField interface{}
	ArgumentList interface{}
	ArgumentList1 interface{}
	ArrayLength interface{}
	ArrayType interface{}
	Assignment interface{}
	BaseType interface{}
	BaseTypeName interface{}
	BasicLit interface{}
	Block interface{}
	BreakStmt interface{}
	BreakStmt1 interface{}
	BuiltinArgs interface{}
	BuiltinArgs1 interface{}
	BuiltinCall interface{}
	BuiltinCall1 interface{}
	BuiltinCall11 interface{}
	Call interface{}
	Call1 interface{}
	Call11 interface{}
	Channel interface{}
	ChannelType interface{}
	ChannelType1 interface{}
	ChannelType11 interface{}
	CommCase interface{}
	CommCase1 interface{}
	CommClause interface{}
	CompositeLit interface{}
	Condition interface{}
	ConstDecl interface{}
	ConstDecl1 interface{}
	ConstDecl11 interface{}
	ConstSpec interface{}
	ConstSpec1 interface{}
	ConstSpec11 interface{}
	ContinueStmt interface{}
	ContinueStmt1 interface{}
	Conversion interface{}
	Conversion1 interface{}
	Declaration interface{}
	DeferStmt interface{}
	Element interface{}
	Element1 interface{}
	ElementIndex interface{}
	ElementList interface{}
	ElementList1 interface{}
	ElementType interface{}
	ExprCaseClause interface{}
	ExprSwitchCase interface{}
	ExprSwitchStmt interface{}
	ExprSwitchStmt1 interface{}
	ExprSwitchStmt2 interface{}
	ExprSwitchStmt3 interface{}
	ExprSwitchStmt4 interface{}
	Expression interface{}
	Expression1 interface{}
	ExpressionList interface{}
	ExpressionList1 interface{}
	ExpressionStmt interface{}
	Factor interface{}
	Factor1 interface{}
	Factor11 interface{}
	FallthroughStmt interface{}
	FieldDecl interface{}
	FieldDecl1 interface{}
	FieldDecl2 interface{}
	FieldName interface{}
	ForClause interface{}
	ForClause1 interface{}
	ForClause2 interface{}
	ForClause3 interface{}
	ForStmt interface{}
	ForStmt1 interface{}
	ForStmt11 interface{}
	Function interface{}
	FunctionBody interface{}
	FunctionDecl interface{}
	FunctionDecl1 interface{}
	FunctionLit interface{}
	FunctionName interface{}
	FunctionType interface{}
	GoStmt interface{}
	GotoStmt interface{}
	IdentifierList interface{}
	IdentifierList1 interface{}
	IfStmt interface{}
	IfStmt1 interface{}
	IfStmt11 interface{}
	IfStmt2 interface{}
	IfStmt21 interface{}
	ImportDecl interface{}
	ImportDecl1 interface{}
	ImportDecl11 interface{}
	ImportPath interface{}
	ImportSpec interface{}
	ImportSpec1 interface{}
	ImportSpec11 interface{}
	IncDecStmt interface{}
	IncDecStmt1 interface{}
	Index interface{}
	InitStmt interface{}
	InterfaceType interface{}
	InterfaceType1 interface{}
	InterfaceTypeName interface{}
	Key interface{}
	KeyType interface{}
	Label interface{}
	LabeledStmt interface{}
	Literal interface{}
	LiteralType interface{}
	LiteralValue interface{}
	LiteralValue1 interface{}
	LiteralValue11 interface{}
	MapType interface{}
	MethodDecl interface{}
	MethodDecl1 interface{}
	MethodExpr interface{}
	MethodName interface{}
	MethodSpec interface{}
	Operand interface{}
	OperandName interface{}
	PackageClause interface{}
	PackageName interface{}
	ParameterDecl interface{}
	ParameterDecl1 interface{}
	ParameterDecl2 interface{}
	ParameterList interface{}
	ParameterList1 interface{}
	Parameters interface{}
	Parameters1 interface{}
	Parameters11 interface{}
	PointerType interface{}
	PostStmt interface{}
	PrimaryExpr interface{}
	PrimaryFactor interface{}
	PrimaryFactor1 interface{}
	PrimaryFactor11 interface{}
	PrimaryTerm interface{}
	PrimaryTerm1 interface{}
	PrimaryTerm11 interface{}
	QualifiedIdent interface{}
	RangeClause interface{}
	RangeClause1 interface{}
	Receiver interface{}
	Receiver1 interface{}
	Receiver2 interface{}
	ReceiverType interface{}
	RecvExpr interface{}
	RecvStmt interface{}
	RecvStmt1 interface{}
	RecvStmt11 interface{}
	Result interface{}
	ReturnStmt interface{}
	ReturnStmt1 interface{}
	SelectStmt interface{}
	SelectStmt1 interface{}
	Selector interface{}
	SendStmt interface{}
	ShortVarDecl interface{}
	Signature interface{}
	Signature1 interface{}
	SimpleStmt interface{}
	Slice interface{}
	Slice1 interface{}
	Slice11 interface{}
	Slice12 interface{}
	Slice2 interface{}
	Slice21 interface{}
	SliceType interface{}
	SourceFile interface{}
	SourceFile1 interface{}
	SourceFile2 interface{}
	Start interface{}
	Statement interface{}
	StatementList interface{}
	StatementList1 interface{}
	StatementList2 interface{}
	StatementList21 interface{}
	StructType interface{}
	StructType1 interface{}
	SwitchStmt interface{}
	Tag interface{}
	Term interface{}
	Term1 interface{}
	TopLevelDecl interface{}
	Type interface{}
	TypeAssertion interface{}
	TypeCaseClause interface{}
	TypeDecl interface{}
	TypeDecl1 interface{}
	TypeDecl11 interface{}
	TypeList interface{}
	TypeList1 interface{}
	TypeLit interface{}
	TypeName interface{}
	TypeSpec interface{}
	TypeSwitchCase interface{}
	TypeSwitchGuard interface{}
	TypeSwitchGuard1 interface{}
	TypeSwitchStmt interface{}
	TypeSwitchStmt1 interface{}
	TypeSwitchStmt2 interface{}
	UnaryExpr interface{}
	UnaryExpr1 interface{}
	UnaryExpr11 interface{}
	Value interface{}
	VarDecl interface{}
	VarDecl1 interface{}
	VarDecl11 interface{}
	VarSpec interface{}
	VarSpec1 interface{}
	VarSpec11 interface{}
)
	
func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}
	
		fmt.Println(v)
	}
}

// End of demo stuff
