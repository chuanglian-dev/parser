%{

//TODO Put your favorite license here
		
// yacc source generated by ebnf2y[1]
// at 2013-08-07 15:13:46.789955162 +0200 CEST.
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
// 
//   [1]: http://github.com/cznic/ebnf2y

package main //TODO real package name

//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"github.com/cznic/strutil"
)

%}

%union {
	item interface{} //TODO insert real field(s)
}

%token	ANDAND
%token	ANDNOT
%token	ASSIGN_OP
%token	COLAS
%token	COMM
%token	DDD
%token	DEC
%token	EQ
%token	FLOAT_LIT
%token	GE
%token	IDENTIFIER
%token	IMAGINARY_LIT
%token	INC
%token	INT_LIT
%token	LE
%token	LSH
%token	NE
%token	OROR
%token	RSH
%token	RUNE_LIT
%token	STRING_LIT

%type	<item> 	/*TODO real type(s), if/where applicable */
	ANDAND
	ANDNOT
	ASSIGN_OP
	COLAS
	COMM
	DDD
	DEC
	EQ
	FLOAT_LIT
	GE
	IDENTIFIER
	IMAGINARY_LIT
	INC
	INT_LIT
	LE
	LSH
	NE
	OROR
	RSH
	RUNE_LIT
	STRING_LIT

%token BREAK
%token CASE
%token CHAN
%token CONST
%token CONTINUE
%token DEFAULT
%token DEFER
%token ELSE
%token FALLTHROUGH
%token FOR
%token FUNC
%token GO
%token GOTO
%token IF
%token IMPORT
%token INTERFACE
%token MAP
%token PACKAGE
%token RANGE
%token RETURN
%token SELECT
%token STRUCT
%token SWITCH
%token TYPE
%token VAR

%type	<item> 	/*TODO real type(s), if/where applicable */
	ArgumentList
	ArrayType
	BaseTypeName
	Block
	Condition
	ConstDecl11
	ConstSpec
	Declaration
	Element
	ElementList1
	ElementType
	ExprSwitchStmt1
	ExprSwitchStmt3
	Expression
	ExpressionList
	ExpressionList1
	FieldDecl1
	ForClause2
	Function
	IdentifierList
	IdentifierList1
	IfStmt
	ImportDecl11
	ImportSpec
	InterfaceType1
	Label
	LiteralValue
	MapType
	MethodDecl1
	MethodName
	ParameterDecl
	ParameterDecl2
	ParameterList1
	Parameters
	PrimaryExpr
	QualifiedIdent
	ReceiverType
	RecvExpr
	SelectStmt1
	SendStmt
	Signature
	SimpleStmt
	Slice2
	SliceType
	SourceFile
	SourceFile1
	SourceFile2
	Start
	Statement
	StatementList
	StatementList1
	StructType
	StructType1
	Type
	TypeDecl11
	TypeList1
	TypeName
	TypeSpec
	TypeSwitchGuard
	TypeSwitchStmt2
	UnaryExpr
	VarDecl11
	VarSpec

/*TODO %left, %right, ... declarations */

%start Start

%%

ArgumentList:
	ExpressionList
	{
		$$ = $1 //TODO 1
	}
|	ExpressionList DDD
	{
		$$ = []ArgumentList{$1, $2} //TODO 2
	}

ArrayType:
	'[' Expression ']' ElementType
	{
		$$ = []ArrayType{"[", $2, "]", $4} //TODO 3
	}

BaseTypeName:
	IDENTIFIER
	{
		$$ = $1 //TODO 4
	}

Block:
	'{' StatementList '}'
	{
		$$ = []Block{"{", $2, "}"} //TODO 5
	}

Condition:
	Expression
	{
		$$ = $1 //TODO 6
	}

ConstDecl11:
	/* EMPTY */
	{
		$$ = []ConstDecl11(nil) //TODO 7
	}
|	ConstDecl11 ConstSpec ';'
	{
		$$ = append($1.([]ConstDecl11), $2, ";") //TODO 8
	}

ConstSpec:
	IdentifierList
	{
		$$ = $1 //TODO 9
	}
|	IdentifierList '=' ExpressionList
	{
		$$ = []ConstSpec{$1, "=", $3} //TODO 10
	}
|	IdentifierList Type '=' ExpressionList
	{
		$$ = []ConstSpec{$1, $2, "=", $4} //TODO 11
	}

Declaration:
	CONST ConstSpec
	{
		$$ = []Declaration{"const", $2} //TODO 12
	}
|	CONST '(' ConstDecl11 ')'
	{
		$$ = []Declaration{"const", "(", $3, ")"} //TODO 13
	}
|	TYPE TypeSpec
	{
		$$ = []Declaration{"type", $2} //TODO 14
	}
|	TYPE '(' TypeDecl11 ')'
	{
		$$ = []Declaration{"type", "(", $3, ")"} //TODO 15
	}
|	VAR VarSpec
	{
		$$ = []Declaration{"var", $2} //TODO 16
	}
|	VAR '(' VarDecl11 ')'
	{
		$$ = []Declaration{"var", "(", $3, ")"} //TODO 17
	}

Element:
	Expression
	{
		$$ = $1 //TODO 18
	}
|	IDENTIFIER ':' Expression
	{
		$$ = []Element{$1, ":", $3} //TODO 19
	}
|	Expression ':' Expression
	{
		$$ = []Element{$1, ":", $3} //TODO 20
	}
|	LiteralValue
	{
		$$ = $1 //TODO 21
	}
|	IDENTIFIER ':' LiteralValue
	{
		$$ = []Element{$1, ":", $3} //TODO 22
	}
|	Expression ':' LiteralValue
	{
		$$ = []Element{$1, ":", $3} //TODO 23
	}

ElementList1:
	/* EMPTY */
	{
		$$ = []ElementList1(nil) //TODO 24
	}
|	ElementList1 ',' Element
	{
		$$ = append($1.([]ElementList1), ",", $3) //TODO 25
	}

ElementType:
	Type
	{
		$$ = $1 //TODO 26
	}

ExprSwitchStmt1:
	/* EMPTY */
	{
		$$ = nil //TODO 27
	}
|	SimpleStmt ';'
	{
		$$ = []ExprSwitchStmt1{$1, ";"} //TODO 28
	}

ExprSwitchStmt3:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt3(nil) //TODO 29
	}
|	ExprSwitchStmt3 CASE ExpressionList ':' StatementList
	{
		$$ = append($1.([]ExprSwitchStmt3), "case", $3, ":", $5) //TODO 30
	}
|	ExprSwitchStmt3 DEFAULT ':' StatementList
	{
		$$ = append($1.([]ExprSwitchStmt3), "default", ":", $4) //TODO 31
	}

Expression:
	UnaryExpr
	{
		$$ = $1 //TODO 32
	}
|	Expression OROR UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 33
	}
|	Expression ANDAND UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 34
	}
|	Expression EQ UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 35
	}
|	Expression NE UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 36
	}
|	Expression '<' UnaryExpr
	{
		$$ = []Expression{$1, "<", $3} //TODO 37
	}
|	Expression LE UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 38
	}
|	Expression '>' UnaryExpr
	{
		$$ = []Expression{$1, ">", $3} //TODO 39
	}
|	Expression GE UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 40
	}
|	Expression '+' UnaryExpr
	{
		$$ = []Expression{$1, "+", $3} //TODO 41
	}
|	Expression '-' UnaryExpr
	{
		$$ = []Expression{$1, "-", $3} //TODO 42
	}
|	Expression '|' UnaryExpr
	{
		$$ = []Expression{$1, "|", $3} //TODO 43
	}
|	Expression '^' UnaryExpr
	{
		$$ = []Expression{$1, "^", $3} //TODO 44
	}
|	Expression '*' UnaryExpr
	{
		$$ = []Expression{$1, "*", $3} //TODO 45
	}
|	Expression '/' UnaryExpr
	{
		$$ = []Expression{$1, "/", $3} //TODO 46
	}
|	Expression '%' UnaryExpr
	{
		$$ = []Expression{$1, "%", $3} //TODO 47
	}
|	Expression LSH UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 48
	}
|	Expression RSH UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 49
	}
|	Expression '&' UnaryExpr
	{
		$$ = []Expression{$1, "&", $3} //TODO 50
	}
|	Expression ANDNOT UnaryExpr
	{
		$$ = []Expression{$1, $2, $3} //TODO 51
	}

ExpressionList:
	Expression ExpressionList1
	{
		$$ = []ExpressionList{$1, $2} //TODO 52
	}

ExpressionList1:
	/* EMPTY */
	{
		$$ = []ExpressionList1(nil) //TODO 53
	}
|	ExpressionList1 ',' Expression
	{
		$$ = append($1.([]ExpressionList1), ",", $3) //TODO 54
	}

FieldDecl1:
	IdentifierList Type
	{
		$$ = []FieldDecl1{$1, $2} //TODO 55
	}
|	TypeName
	{
		$$ = $1 //TODO 56
	}
|	'*' TypeName
	{
		$$ = []FieldDecl1{"*", $2} //TODO 57
	}

ForClause2:
	/* EMPTY */
	{
		$$ = nil //TODO 58
	}
|	Condition
	{
		$$ = $1 //TODO 59
	}

Function:
	Signature Block
	{
		$$ = []Function{$1, $2} //TODO 60
	}

IdentifierList:
	IDENTIFIER IdentifierList1
	{
		$$ = []IdentifierList{$1, $2} //TODO 61
	}

IdentifierList1:
	/* EMPTY */
	{
		$$ = []IdentifierList1(nil) //TODO 62
	}
|	IdentifierList1 ',' IDENTIFIER
	{
		$$ = append($1.([]IdentifierList1), ",", $3) //TODO 63
	}

IfStmt:
	IF Expression Block
	{
		$$ = []IfStmt{"if", $2, $3} //TODO 64
	}
|	IF SimpleStmt ';' Expression Block
	{
		$$ = []IfStmt{"if", $2, ";", $4, $5} //TODO 65
	}
|	IF Expression Block ELSE IfStmt
	{
		$$ = []IfStmt{"if", $2, $3, "else", $5} //TODO 66
	}
|	IF SimpleStmt ';' Expression Block ELSE IfStmt
	{
		$$ = []IfStmt{"if", $2, ";", $4, $5, "else", $7} //TODO 67
	}
|	IF Expression Block ELSE Block
	{
		$$ = []IfStmt{"if", $2, $3, "else", $5} //TODO 68
	}
|	IF SimpleStmt ';' Expression Block ELSE Block
	{
		$$ = []IfStmt{"if", $2, ";", $4, $5, "else", $7} //TODO 69
	}

ImportDecl11:
	/* EMPTY */
	{
		$$ = []ImportDecl11(nil) //TODO 70
	}
|	ImportDecl11 ImportSpec ';'
	{
		$$ = append($1.([]ImportDecl11), $2, ";") //TODO 71
	}

ImportSpec:
	STRING_LIT
	{
		$$ = $1 //TODO 72
	}
|	'.' STRING_LIT
	{
		$$ = []ImportSpec{".", $2} //TODO 73
	}
|	IDENTIFIER STRING_LIT
	{
		$$ = []ImportSpec{$1, $2} //TODO 74
	}

InterfaceType1:
	/* EMPTY */
	{
		$$ = []InterfaceType1(nil) //TODO 75
	}
|	InterfaceType1 MethodName Signature ';'
	{
		$$ = append($1.([]InterfaceType1), $2, $3, ";") //TODO 76
	}
|	InterfaceType1 TypeName ';'
	{
		$$ = append($1.([]InterfaceType1), $2, ";") //TODO 77
	}

Label:
	IDENTIFIER
	{
		$$ = $1 //TODO 78
	}

LiteralValue:
	'{' '}'
	{
		$$ = []LiteralValue{"{", "}"} //TODO 79
	}
|	'{' Element ElementList1 '}'
	{
		$$ = []LiteralValue{"{", $2, $3, "}"} //TODO 80
	}
|	'{' Element ElementList1 ',' '}'
	{
		$$ = []LiteralValue{"{", $2, $3, ",", "}"} //TODO 81
	}

MapType:
	MAP '[' Type ']' ElementType
	{
		$$ = []MapType{"map", "[", $3, "]", $5} //TODO 82
	}

MethodDecl1:
	Function
	{
		$$ = $1 //TODO 83
	}
|	Signature
	{
		$$ = $1 //TODO 84
	}

MethodName:
	IDENTIFIER
	{
		$$ = $1 //TODO 85
	}

ParameterDecl:
	ParameterDecl2 Type
	{
		$$ = []ParameterDecl{$1, $2} //TODO 86
	}
|	IdentifierList ParameterDecl2 Type
	{
		$$ = []ParameterDecl{$1, $2, $3} //TODO 87
	}

ParameterDecl2:
	/* EMPTY */
	{
		$$ = nil //TODO 88
	}
|	DDD
	{
		$$ = $1 //TODO 89
	}

ParameterList1:
	/* EMPTY */
	{
		$$ = []ParameterList1(nil) //TODO 90
	}
|	ParameterList1 ',' ParameterDecl
	{
		$$ = append($1.([]ParameterList1), ",", $3) //TODO 91
	}

Parameters:
	'(' ')'
	{
		$$ = []Parameters{"(", ")"} //TODO 92
	}
|	'(' ParameterDecl ParameterList1 ')'
	{
		$$ = []Parameters{"(", $2, $3, ")"} //TODO 93
	}
|	'(' ParameterDecl ParameterList1 ',' ')'
	{
		$$ = []Parameters{"(", $2, $3, ",", ")"} //TODO 94
	}

PrimaryExpr:
	INT_LIT
	{
		$$ = $1 //TODO 95
	}
|	FLOAT_LIT
	{
		$$ = $1 //TODO 96
	}
|	IMAGINARY_LIT
	{
		$$ = $1 //TODO 97
	}
|	RUNE_LIT
	{
		$$ = $1 //TODO 98
	}
|	STRING_LIT
	{
		$$ = $1 //TODO 99
	}
|	StructType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 100
	}
|	ArrayType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 101
	}
|	'[' DDD ']' ElementType LiteralValue
	{
		$$ = []PrimaryExpr{"[", $2, "]", $4, $5} //TODO 102
	}
|	SliceType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 103
	}
|	MapType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 104
	}
|	TypeName LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 105
	}
|	FUNC Function
	{
		$$ = []PrimaryExpr{"func", $2} //TODO 106
	}
|	IDENTIFIER
	{
		$$ = $1 //TODO 107
	}
|	QualifiedIdent
	{
		$$ = $1 //TODO 108
	}
|	ReceiverType '.' MethodName
	{
		$$ = []PrimaryExpr{$1, ".", $3} //TODO 109
	}
|	'(' Expression ')'
	{
		$$ = []PrimaryExpr{"(", $2, ")"} //TODO 110
	}
|	Type '(' Expression ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ")"} //TODO 111
	}
|	Type '(' Expression ',' ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", ")"} //TODO 112
	}
|	IDENTIFIER '(' ')'
	{
		$$ = []PrimaryExpr{$1, "(", ")"} //TODO 113
	}
|	IDENTIFIER '(' Type ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ")"} //TODO 114
	}
|	IDENTIFIER '(' Type ',' ArgumentList ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", $5, ")"} //TODO 115
	}
|	IDENTIFIER '(' ArgumentList ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ")"} //TODO 116
	}
|	IDENTIFIER '(' Type ',' ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", ")"} //TODO 117
	}
|	IDENTIFIER '(' Type ',' ArgumentList ',' ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", $5, ",", ")"} //TODO 118
	}
|	IDENTIFIER '(' ArgumentList ',' ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", ")"} //TODO 119
	}
|	PrimaryExpr '.' IDENTIFIER
	{
		$$ = []PrimaryExpr{$1, ".", $3} //TODO 120
	}
|	PrimaryExpr '[' Expression ']'
	{
		$$ = []PrimaryExpr{$1, "[", $3, "]"} //TODO 121
	}
|	PrimaryExpr '[' ':' Slice2 ']'
	{
		$$ = []PrimaryExpr{$1, "[", ":", $4, "]"} //TODO 122
	}
|	PrimaryExpr '[' Expression ':' Slice2 ']'
	{
		$$ = []PrimaryExpr{$1, "[", $3, ":", $5, "]"} //TODO 123
	}
|	PrimaryExpr '.' '(' Type ')'
	{
		$$ = []PrimaryExpr{$1, ".", "(", $4, ")"} //TODO 124
	}
|	PrimaryExpr '(' ')'
	{
		$$ = []PrimaryExpr{$1, "(", ")"} //TODO 125
	}
|	PrimaryExpr '(' ArgumentList ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ")"} //TODO 126
	}
|	PrimaryExpr '(' ArgumentList ',' ')'
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", ")"} //TODO 127
	}

QualifiedIdent:
	IDENTIFIER '.' IDENTIFIER
	{
		$$ = []QualifiedIdent{$1, ".", $3} //TODO 128
	}

ReceiverType:
	TypeName
	{
		$$ = $1 //TODO 129
	}
|	'(' '*' TypeName ')'
	{
		$$ = []ReceiverType{"(", "*", $3, ")"} //TODO 130
	}
|	'(' ReceiverType ')'
	{
		$$ = []ReceiverType{"(", $2, ")"} //TODO 131
	}

RecvExpr:
	Expression
	{
		$$ = $1 //TODO 132
	}

SelectStmt1:
	/* EMPTY */
	{
		$$ = []SelectStmt1(nil) //TODO 133
	}
|	SelectStmt1 CASE SendStmt ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, ":", $5) //TODO 134
	}
|	SelectStmt1 CASE RecvExpr ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, ":", $5) //TODO 135
	}
|	SelectStmt1 CASE ExpressionList '=' RecvExpr ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, "=", $5, ":", $7) //TODO 136
	}
|	SelectStmt1 CASE IdentifierList COLAS RecvExpr ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, $4, $5, ":", $7) //TODO 137
	}
|	SelectStmt1 DEFAULT ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "default", ":", $4) //TODO 138
	}

SendStmt:
	Expression COMM Expression
	{
		$$ = []SendStmt{$1, $2, $3} //TODO 139
	}

Signature:
	Parameters
	{
		$$ = $1 //TODO 140
	}
|	Parameters Parameters
	{
		$$ = []Signature{$1, $2} //TODO 141
	}
|	Parameters Type
	{
		$$ = []Signature{$1, $2} //TODO 142
	}

SimpleStmt:
	/* EMPTY */
	{
		$$ = nil //TODO 143
	}
|	Expression
	{
		$$ = $1 //TODO 144
	}
|	SendStmt
	{
		$$ = $1 //TODO 145
	}
|	Expression INC
	{
		$$ = []SimpleStmt{$1, $2} //TODO 146
	}
|	Expression DEC
	{
		$$ = []SimpleStmt{$1, $2} //TODO 147
	}
|	ExpressionList ASSIGN_OP ExpressionList
	{
		$$ = []SimpleStmt{$1, $2, $3} //TODO 148
	}
|	IdentifierList COLAS ExpressionList
	{
		$$ = []SimpleStmt{$1, $2, $3} //TODO 149
	}

Slice2:
	/* EMPTY */
	{
		$$ = nil //TODO 150
	}
|	Expression
	{
		$$ = $1 //TODO 151
	}

SliceType:
	'[' ']' ElementType
	{
		$$ = []SliceType{"[", "]", $3} //TODO 152
	}

SourceFile:
	PACKAGE IDENTIFIER ';' SourceFile1 SourceFile2
	{
		$$ = []SourceFile{"package", $2, ";", $4, $5} //TODO 153
	}

SourceFile1:
	/* EMPTY */
	{
		$$ = []SourceFile1(nil) //TODO 154
	}
|	SourceFile1 IMPORT ImportSpec ';'
	{
		$$ = append($1.([]SourceFile1), "import", $3, ";") //TODO 155
	}
|	SourceFile1 IMPORT '(' ImportDecl11 ')' ';'
	{
		$$ = append($1.([]SourceFile1), "import", "(", $4, ")", ";") //TODO 156
	}

SourceFile2:
	/* EMPTY */
	{
		$$ = []SourceFile2(nil) //TODO 157
	}
|	SourceFile2 Declaration ';'
	{
		$$ = append($1.([]SourceFile2), $2, ";") //TODO 158
	}
|	SourceFile2 FUNC IDENTIFIER Function ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 159
	}
|	SourceFile2 FUNC IDENTIFIER Signature ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 160
	}
|	SourceFile2 FUNC '(' BaseTypeName ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, ")", $6, $7, ";") //TODO 161
	}
|	SourceFile2 FUNC '(' IDENTIFIER BaseTypeName ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, $5, ")", $7, $8, ";") //TODO 162
	}
|	SourceFile2 FUNC '(' '*' BaseTypeName ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", "*", $5, ")", $7, $8, ";") //TODO 163
	}
|	SourceFile2 FUNC '(' IDENTIFIER '*' BaseTypeName ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, "*", $6, ")", $8, $9, ";") //TODO 164
	}

Start:
	SourceFile
	{
		_parserResult = $1 //TODO 165
	}

Statement:
	Declaration
	{
		$$ = $1 //TODO 166
	}
|	Label ':' Statement
	{
		$$ = []Statement{$1, ":", $3} //TODO 167
	}
|	SimpleStmt
	{
		$$ = $1 //TODO 168
	}
|	GO Expression
	{
		$$ = []Statement{"go", $2} //TODO 169
	}
|	RETURN
	{
		$$ = "return" //TODO 170
	}
|	RETURN ExpressionList
	{
		$$ = []Statement{"return", $2} //TODO 171
	}
|	BREAK
	{
		$$ = "break" //TODO 172
	}
|	BREAK Label
	{
		$$ = []Statement{"break", $2} //TODO 173
	}
|	CONTINUE
	{
		$$ = "continue" //TODO 174
	}
|	CONTINUE Label
	{
		$$ = []Statement{"continue", $2} //TODO 175
	}
|	GOTO Label
	{
		$$ = []Statement{"goto", $2} //TODO 176
	}
|	FALLTHROUGH
	{
		$$ = "fallthrough" //TODO 177
	}
|	Block
	{
		$$ = $1 //TODO 178
	}
|	IfStmt
	{
		$$ = $1 //TODO 179
	}
|	SWITCH ExprSwitchStmt1 '{' ExprSwitchStmt3 '}'
	{
		$$ = []Statement{"switch", $2, "{", $4, "}"} //TODO 180
	}
|	SWITCH ExprSwitchStmt1 Expression '{' ExprSwitchStmt3 '}'
	{
		$$ = []Statement{"switch", $2, $3, "{", $5, "}"} //TODO 181
	}
|	SWITCH TypeSwitchGuard '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, "{", $4, "}"} //TODO 182
	}
|	SWITCH SimpleStmt ';' TypeSwitchGuard '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, ";", $4, "{", $6, "}"} //TODO 183
	}
|	SELECT '{' SelectStmt1 '}'
	{
		$$ = []Statement{"select", "{", $3, "}"} //TODO 184
	}
|	FOR Block
	{
		$$ = []Statement{"for", $2} //TODO 185
	}
|	FOR Condition Block
	{
		$$ = []Statement{"for", $2, $3} //TODO 186
	}
|	FOR ';' ForClause2 ';' Block
	{
		$$ = []Statement{"for", ";", $3, ";", $5} //TODO 187
	}
|	FOR ';' ForClause2 ';' SimpleStmt Block
	{
		$$ = []Statement{"for", ";", $3, ";", $5, $6} //TODO 188
	}
|	FOR SimpleStmt ';' ForClause2 ';' Block
	{
		$$ = []Statement{"for", $2, ";", $4, ";", $6} //TODO 189
	}
|	FOR SimpleStmt ';' ForClause2 ';' SimpleStmt Block
	{
		$$ = []Statement{"for", $2, ";", $4, ";", $6, $7} //TODO 190
	}
|	FOR ExpressionList '=' RANGE Expression Block
	{
		$$ = []Statement{"for", $2, "=", "range", $5, $6} //TODO 191
	}
|	FOR IdentifierList COLAS RANGE Expression Block
	{
		$$ = []Statement{"for", $2, $3, "range", $5, $6} //TODO 192
	}
|	DEFER Expression
	{
		$$ = []Statement{"defer", $2} //TODO 193
	}

StatementList:
	StatementList1
	{
		$$ = $1 //TODO 194
	}

StatementList1:
	/* EMPTY */
	{
		$$ = []StatementList1(nil) //TODO 195
	}
|	StatementList1 Statement ';'
	{
		$$ = append($1.([]StatementList1), $2, ";") //TODO 196
	}

StructType:
	STRUCT '{' StructType1 '}'
	{
		$$ = []StructType{"struct", "{", $3, "}"} //TODO 197
	}

StructType1:
	/* EMPTY */
	{
		$$ = []StructType1(nil) //TODO 198
	}
|	StructType1 FieldDecl1 ';'
	{
		$$ = append($1.([]StructType1), $2, ";") //TODO 199
	}
|	StructType1 FieldDecl1 STRING_LIT ';'
	{
		$$ = append($1.([]StructType1), $2, $3, ";") //TODO 200
	}

Type:
	TypeName
	{
		$$ = $1 //TODO 201
	}
|	ArrayType
	{
		$$ = $1 //TODO 202
	}
|	StructType
	{
		$$ = $1 //TODO 203
	}
|	'*' Type
	{
		$$ = []Type{"*", $2} //TODO 204
	}
|	FUNC Signature
	{
		$$ = []Type{"func", $2} //TODO 205
	}
|	INTERFACE '{' InterfaceType1 '}'
	{
		$$ = []Type{"interface", "{", $3, "}"} //TODO 206
	}
|	SliceType
	{
		$$ = $1 //TODO 207
	}
|	MapType
	{
		$$ = $1 //TODO 208
	}
|	CHAN ElementType
	{
		$$ = []Type{"chan", $2} //TODO 209
	}
|	CHAN COMM ElementType
	{
		$$ = []Type{"chan", $2, $3} //TODO 210
	}
|	COMM CHAN ElementType
	{
		$$ = []Type{$1, "chan", $3} //TODO 211
	}
|	'(' Type ')'
	{
		$$ = []Type{"(", $2, ")"} //TODO 212
	}

TypeDecl11:
	/* EMPTY */
	{
		$$ = []TypeDecl11(nil) //TODO 213
	}
|	TypeDecl11 TypeSpec ';'
	{
		$$ = append($1.([]TypeDecl11), $2, ";") //TODO 214
	}

TypeList1:
	/* EMPTY */
	{
		$$ = []TypeList1(nil) //TODO 215
	}
|	TypeList1 ',' Type
	{
		$$ = append($1.([]TypeList1), ",", $3) //TODO 216
	}

TypeName:
	IDENTIFIER
	{
		$$ = $1 //TODO 217
	}
|	QualifiedIdent
	{
		$$ = $1 //TODO 218
	}

TypeSpec:
	IDENTIFIER Type
	{
		$$ = []TypeSpec{$1, $2} //TODO 219
	}

TypeSwitchGuard:
	PrimaryExpr '.' '(' TYPE ')'
	{
		$$ = []TypeSwitchGuard{$1, ".", "(", "type", ")"} //TODO 220
	}
|	IDENTIFIER COLAS PrimaryExpr '.' '(' TYPE ')'
	{
		$$ = []TypeSwitchGuard{$1, $2, $3, ".", "(", "type", ")"} //TODO 221
	}

TypeSwitchStmt2:
	/* EMPTY */
	{
		$$ = []TypeSwitchStmt2(nil) //TODO 222
	}
|	TypeSwitchStmt2 CASE Type TypeList1 ':' StatementList
	{
		$$ = append($1.([]TypeSwitchStmt2), "case", $3, $4, ":", $6) //TODO 223
	}
|	TypeSwitchStmt2 DEFAULT ':' StatementList
	{
		$$ = append($1.([]TypeSwitchStmt2), "default", ":", $4) //TODO 224
	}

UnaryExpr:
	PrimaryExpr
	{
		$$ = $1 //TODO 225
	}
|	'+' UnaryExpr
	{
		$$ = []UnaryExpr{"+", $2} //TODO 226
	}
|	'-' UnaryExpr
	{
		$$ = []UnaryExpr{"-", $2} //TODO 227
	}
|	'!' UnaryExpr
	{
		$$ = []UnaryExpr{"!", $2} //TODO 228
	}
|	'^' UnaryExpr
	{
		$$ = []UnaryExpr{"^", $2} //TODO 229
	}
|	'*' UnaryExpr
	{
		$$ = []UnaryExpr{"*", $2} //TODO 230
	}
|	'&' UnaryExpr
	{
		$$ = []UnaryExpr{"&", $2} //TODO 231
	}
|	COMM UnaryExpr
	{
		$$ = []UnaryExpr{$1, $2} //TODO 232
	}

VarDecl11:
	/* EMPTY */
	{
		$$ = []VarDecl11(nil) //TODO 233
	}
|	VarDecl11 VarSpec ';'
	{
		$$ = append($1.([]VarDecl11), $2, ";") //TODO 234
	}

VarSpec:
	IdentifierList Type
	{
		$$ = []VarSpec{$1, $2} //TODO 235
	}
|	IdentifierList Type '=' ExpressionList
	{
		$$ = []VarSpec{$1, $2, "=", $4} //TODO 236
	}
|	IdentifierList '=' ExpressionList
	{
		$$ = []VarSpec{$1, "=", $3} //TODO 237
	}

%%

//TODO remove demo stuff below

var _parserResult interface{}

type (
	ArgumentList interface{}
	ArrayType interface{}
	BaseTypeName interface{}
	Block interface{}
	Condition interface{}
	ConstDecl11 interface{}
	ConstSpec interface{}
	Declaration interface{}
	Element interface{}
	ElementList1 interface{}
	ElementType interface{}
	ExprSwitchStmt1 interface{}
	ExprSwitchStmt3 interface{}
	Expression interface{}
	ExpressionList interface{}
	ExpressionList1 interface{}
	FieldDecl1 interface{}
	ForClause2 interface{}
	Function interface{}
	IdentifierList interface{}
	IdentifierList1 interface{}
	IfStmt interface{}
	ImportDecl11 interface{}
	ImportSpec interface{}
	InterfaceType1 interface{}
	Label interface{}
	LiteralValue interface{}
	MapType interface{}
	MethodDecl1 interface{}
	MethodName interface{}
	ParameterDecl interface{}
	ParameterDecl2 interface{}
	ParameterList1 interface{}
	Parameters interface{}
	PrimaryExpr interface{}
	QualifiedIdent interface{}
	ReceiverType interface{}
	RecvExpr interface{}
	SelectStmt1 interface{}
	SendStmt interface{}
	Signature interface{}
	SimpleStmt interface{}
	Slice2 interface{}
	SliceType interface{}
	SourceFile interface{}
	SourceFile1 interface{}
	SourceFile2 interface{}
	Start interface{}
	Statement interface{}
	StatementList interface{}
	StatementList1 interface{}
	StructType interface{}
	StructType1 interface{}
	Type interface{}
	TypeDecl11 interface{}
	TypeList1 interface{}
	TypeName interface{}
	TypeSpec interface{}
	TypeSwitchGuard interface{}
	TypeSwitchStmt2 interface{}
	UnaryExpr interface{}
	VarDecl11 interface{}
	VarSpec interface{}
)
	
func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}
	
		fmt.Println(v)
	}
}

// End of demo stuff
