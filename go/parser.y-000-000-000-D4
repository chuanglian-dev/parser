%{

//TODO Put your favorite license here
		
// yacc source generated by ebnf2y[1]
// at 2013-08-20 22:39:51.283502876 +0200 CEST.
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
// 
//   [1]: http://github.com/cznic/ebnf2y

package main //TODO real package name

//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"github.com/cznic/strutil"
)

%}

%union {
	item interface{} //TODO insert real field(s)
}

%token	ANDAND
%token	ANDNOT
%token	ASSIGN_OP
%token	BUILT_IN_NAME
%token	CHANCOMM
%token	COMM
%token	COMMCHAN
%token	DDD
%token	DEC
%token	EQ
%token	FLOAT_LIT
%token	GE
%token	IDENTIFIER_LIST
%token	IDLIST_COLAS
%token	IMAGINARY_LIT
%token	INC
%token	INT_LIT
%token	LE
%token	LSH
%token	NE
%token	NON_TYPE_NAME
%token	OCOMMA_RPAREN
%token	OROR
%token	PACK_NAME
%token	RSH
%token	RUNE_LIT
%token	STRING_LIT
%token	TYPE_NAME

%type	<item> 	/*TODO real type(s), if/where applicable */
	ANDAND
	ANDNOT
	ASSIGN_OP
	BUILT_IN_NAME
	CHANCOMM
	COMM
	COMMCHAN
	DDD
	DEC
	EQ
	FLOAT_LIT
	GE
	IDENTIFIER_LIST
	IDLIST_COLAS
	IMAGINARY_LIT
	INC
	INT_LIT
	LE
	LSH
	NE
	NON_TYPE_NAME
	OCOMMA_RPAREN
	OROR
	PACK_NAME
	RSH
	RUNE_LIT
	STRING_LIT
	TYPE_NAME

%token BREAK
%token CASE
%token CHAN
%token CONST
%token CONTINUE
%token DEFAULT
%token DEFER
%token ELSE
%token FALLTHROUGH
%token FOR
%token FUNC
%token GO
%token GOTO
%token IF
%token IMPORT
%token INTERFACE
%token MAP
%token PACKAGE
%token RANGE
%token RETURN
%token SELECT
%token STRUCT
%token SWITCH
%token TYPE
%token VAR

%type	<item> 	/*TODO real type(s), if/where applicable */
	ArgumentList
	ArrayType
	Block
	Condition
	ConstDecl11
	ConstSpec
	Declaration
	Element
	ElementList1
	ElementType
	ExprSwitchStmt2
	ExprSwitchStmt3
	Expression
	ExpressionList
	ExpressionList1
	FieldDecl2
	Function
	IfStmt
	IfStmt2
	ImportDecl11
	ImportPath
	ImportSpec
	InterfaceType1
	Label
	LiteralValue
	MapType
	MethodDecl1
	MethodName
	ParameterDecl
	ParameterDecl1
	ParameterList1
	Parameters
	PrimaryExpr
	SelectStmt1
	SendStmt
	Signature
	SimpleStmt
	Slice1
	SliceType
	SourceFile
	SourceFile1
	SourceFile2
	Start
	Statement
	StatementList
	StatementList1
	StructType
	StructType1
	Type
	TypeDecl11
	TypeList1
	TypeLit
	TypeName
	TypeSpec
	TypeSwitchStmt2
	UnaryExpr
	VarDecl11
	VarSpec

/*TODO %left, %right, ... declarations */

%left		OROR
%left		ANDAND
%left		EQ NE LE GE '<' '>'
%left		'+' '-' '|' '^'
%left		'*' '/' '%' '&' LSH RSH ANDNOT

%left	notLParen // in Signature
%left	'('
%left	notRParen // in Type
%left	')'

%start Start

%%

ArgumentList:
	ExpressionList
	{
		$$ = $1 //TODO 1
	}
|	ExpressionList DDD
	{
		$$ = []ArgumentList{$1, $2} //TODO 2
	}

ArrayType:
	'[' Expression ']' ElementType
	{
		$$ = []ArrayType{"[", $2, "]", $4} //TODO 3
	}

Block:
	'{' StatementList '}'
	{
		$$ = []Block{"{", $2, "}"} //TODO 4
	}

Condition:
	Expression
	{
		$$ = $1 //TODO 5
	}

ConstDecl11:
	/* EMPTY */
	{
		$$ = []ConstDecl11(nil) //TODO 6
	}
|	ConstDecl11 ConstSpec ';'
	{
		$$ = append($1.([]ConstDecl11), $2, ";") //TODO 7
	}

ConstSpec:
	IDENTIFIER_LIST
	{
		$$ = $1 //TODO 8
	}
|	IDENTIFIER_LIST '=' ExpressionList
	{
		$$ = []ConstSpec{$1, "=", $3} //TODO 9
	}
|	IDENTIFIER_LIST Type '=' ExpressionList
	{
		$$ = []ConstSpec{$1, $2, "=", $4} //TODO 10
	}

Declaration:
	CONST ConstSpec
	{
		$$ = []Declaration{"const", $2} //TODO 11
	}
|	CONST '(' ConstDecl11 ')'
	{
		$$ = []Declaration{"const", "(", $3, ")"} //TODO 12
	}
|	TYPE TypeSpec
	{
		$$ = []Declaration{"type", $2} //TODO 13
	}
|	TYPE '(' TypeDecl11 ')'
	{
		$$ = []Declaration{"type", "(", $3, ")"} //TODO 14
	}
|	VAR VarSpec
	{
		$$ = []Declaration{"var", $2} //TODO 15
	}
|	VAR '(' VarDecl11 ')'
	{
		$$ = []Declaration{"var", "(", $3, ")"} //TODO 16
	}

Element:
	Expression
	{
		$$ = $1 //TODO 17
	}
|	Expression ':' Expression
	{
		$$ = []Element{$1, ":", $3} //TODO 18
	}
|	LiteralValue
	{
		$$ = $1 //TODO 19
	}
|	Expression ':' LiteralValue
	{
		$$ = []Element{$1, ":", $3} //TODO 20
	}

ElementList1:
	/* EMPTY */
	{
		$$ = []ElementList1(nil) //TODO 21
	}
|	ElementList1 ',' Element
	{
		$$ = append($1.([]ElementList1), ",", $3) //TODO 22
	}

ElementType:
	Type
	{
		$$ = $1 //TODO 23
	}

ExprSwitchStmt2:
	/* EMPTY */
	{
		$$ = nil //TODO 24
	}
|	Expression
	{
		$$ = $1 //TODO 25
	}

ExprSwitchStmt3:
	/* EMPTY */
	{
		$$ = []ExprSwitchStmt3(nil) //TODO 26
	}
|	ExprSwitchStmt3 CASE ExpressionList ':' StatementList
	{
		$$ = append($1.([]ExprSwitchStmt3), "case", $3, ":", $5) //TODO 27
	}
|	ExprSwitchStmt3 DEFAULT ':' StatementList
	{
		$$ = append($1.([]ExprSwitchStmt3), "default", ":", $4) //TODO 28
	}

Expression:
	UnaryExpr
	{
		$$ = $1 //TODO 29
	}
|	Expression OROR Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 30
	}
|	Expression ANDAND Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 31
	}
|	Expression EQ Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 32
	}
|	Expression NE Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 33
	}
|	Expression '<' Expression
	{
		$$ = []Expression{$1, "<", $3} //TODO 34
	}
|	Expression LE Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 35
	}
|	Expression '>' Expression
	{
		$$ = []Expression{$1, ">", $3} //TODO 36
	}
|	Expression GE Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 37
	}
|	Expression '+' Expression
	{
		$$ = []Expression{$1, "+", $3} //TODO 38
	}
|	Expression '-' Expression
	{
		$$ = []Expression{$1, "-", $3} //TODO 39
	}
|	Expression '|' Expression
	{
		$$ = []Expression{$1, "|", $3} //TODO 40
	}
|	Expression '^' Expression
	{
		$$ = []Expression{$1, "^", $3} //TODO 41
	}
|	Expression '*' Expression
	{
		$$ = []Expression{$1, "*", $3} //TODO 42
	}
|	Expression '/' Expression
	{
		$$ = []Expression{$1, "/", $3} //TODO 43
	}
|	Expression '%' Expression
	{
		$$ = []Expression{$1, "%", $3} //TODO 44
	}
|	Expression LSH Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 45
	}
|	Expression RSH Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 46
	}
|	Expression '&' Expression
	{
		$$ = []Expression{$1, "&", $3} //TODO 47
	}
|	Expression ANDNOT Expression
	{
		$$ = []Expression{$1, $2, $3} //TODO 48
	}

ExpressionList:
	Expression ExpressionList1
	{
		$$ = []ExpressionList{$1, $2} //TODO 49
	}

ExpressionList1:
	/* EMPTY */
	{
		$$ = []ExpressionList1(nil) //TODO 50
	}
|	ExpressionList1 ',' Expression
	{
		$$ = append($1.([]ExpressionList1), ",", $3) //TODO 51
	}

FieldDecl2:
	/* EMPTY */
	{
		$$ = nil //TODO 52
	}
|	STRING_LIT
	{
		$$ = $1 //TODO 53
	}

Function:
	Signature Block
	{
		$$ = []Function{$1, $2} //TODO 54
	}

IfStmt:
	IF Expression Block IfStmt2
	{
		$$ = []IfStmt{"if", $2, $3, $4} //TODO 55
	}
|	IF SimpleStmt ';' Expression Block IfStmt2
	{
		$$ = []IfStmt{"if", $2, ";", $4, $5, $6} //TODO 56
	}

IfStmt2:
	/* EMPTY */
	{
		$$ = nil //TODO 57
	}
|	ELSE IfStmt
	{
		$$ = []IfStmt2{"else", $2} //TODO 58
	}
|	ELSE Block
	{
		$$ = []IfStmt2{"else", $2} //TODO 59
	}

ImportDecl11:
	/* EMPTY */
	{
		$$ = []ImportDecl11(nil) //TODO 60
	}
|	ImportDecl11 ImportSpec ';'
	{
		$$ = append($1.([]ImportDecl11), $2, ";") //TODO 61
	}

ImportPath:
	STRING_LIT
	{
		$$ = $1 //TODO 62
	}

ImportSpec:
	ImportPath
	{
		$$ = $1 //TODO 63
	}
|	'.' ImportPath
	{
		$$ = []ImportSpec{".", $2} //TODO 64
	}
|	NON_TYPE_NAME ImportPath
	{
		$$ = []ImportSpec{$1, $2} //TODO 65
	}
|	TYPE_NAME ImportPath
	{
		$$ = []ImportSpec{$1, $2} //TODO 66
	}

InterfaceType1:
	/* EMPTY */
	{
		$$ = []InterfaceType1(nil) //TODO 67
	}
|	InterfaceType1 MethodName Signature ';'
	{
		$$ = append($1.([]InterfaceType1), $2, $3, ";") //TODO 68
	}
|	InterfaceType1 TypeName ';'
	{
		$$ = append($1.([]InterfaceType1), $2, ";") //TODO 69
	}

Label:
	NON_TYPE_NAME
	{
		$$ = $1 //TODO 70
	}
|	TYPE_NAME
	{
		$$ = $1 //TODO 71
	}

LiteralValue:
	'{' '}'
	{
		$$ = []LiteralValue{"{", "}"} //TODO 72
	}
|	'{' Element ElementList1 '}'
	{
		$$ = []LiteralValue{"{", $2, $3, "}"} //TODO 73
	}
|	'{' Element ElementList1 ',' '}'
	{
		$$ = []LiteralValue{"{", $2, $3, ",", "}"} //TODO 74
	}

MapType:
	MAP '[' Type ']' ElementType
	{
		$$ = []MapType{"map", "[", $3, "]", $5} //TODO 75
	}

MethodDecl1:
	Function
	{
		$$ = $1 //TODO 76
	}
|	Signature
	{
		$$ = $1 //TODO 77
	}

MethodName:
	NON_TYPE_NAME
	{
		$$ = $1 //TODO 78
	}
|	TYPE_NAME
	{
		$$ = $1 //TODO 79
	}

ParameterDecl:
	ParameterDecl1 Type
	{
		$$ = []ParameterDecl{$1, $2} //TODO 80
	}
|	ParameterDecl1 DDD Type
	{
		$$ = []ParameterDecl{$1, $2, $3} //TODO 81
	}

ParameterDecl1:
	/* EMPTY */
	{
		$$ = nil //TODO 82
	}
|	IDENTIFIER_LIST
	{
		$$ = $1 //TODO 83
	}

ParameterList1:
	/* EMPTY */
	{
		$$ = []ParameterList1(nil) //TODO 84
	}
|	ParameterList1 ',' ParameterDecl
	{
		$$ = append($1.([]ParameterList1), ",", $3) //TODO 85
	}

Parameters:
	'(' ')'
	{
		$$ = []Parameters{"(", ")"} //TODO 86
	}
|	'(' ParameterDecl ParameterList1 OCOMMA_RPAREN
	{
		$$ = []Parameters{"(", $2, $3, $4} //TODO 87
	}

PrimaryExpr:
	INT_LIT
	{
		$$ = $1 //TODO 88
	}
|	FLOAT_LIT
	{
		$$ = $1 //TODO 89
	}
|	IMAGINARY_LIT
	{
		$$ = $1 //TODO 90
	}
|	RUNE_LIT
	{
		$$ = $1 //TODO 91
	}
|	STRING_LIT
	{
		$$ = $1 //TODO 92
	}
|	StructType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 93
	}
|	ArrayType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 94
	}
|	'[' DDD ']' ElementType LiteralValue
	{
		$$ = []PrimaryExpr{"[", $2, "]", $4, $5} //TODO 95
	}
|	SliceType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 96
	}
|	MapType LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 97
	}
|	TypeName LiteralValue
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 98
	}
|	FUNC Function
	{
		$$ = []PrimaryExpr{"func", $2} //TODO 99
	}
|	NON_TYPE_NAME
	{
		$$ = $1 //TODO 100
	}
|	PACK_NAME NON_TYPE_NAME
	{
		$$ = []PrimaryExpr{$1, $2} //TODO 101
	}
|	TypeName '.' MethodName
	{
		$$ = []PrimaryExpr{$1, ".", $3} //TODO 102
	}
|	'(' '*' TypeName ')' '.' MethodName
	{
		$$ = []PrimaryExpr{"(", "*", $3, ")", ".", $6} //TODO 103
	}
|	'(' TypeName ')' '.' MethodName
	{
		$$ = []PrimaryExpr{"(", $2, ")", ".", $5} //TODO 104
	}
|	'(' Expression ')'
	{
		$$ = []PrimaryExpr{"(", $2, ")"} //TODO 105
	}
|	Type '(' Expression OCOMMA_RPAREN
	{
		$$ = []PrimaryExpr{$1, "(", $3, $4} //TODO 106
	}
|	BUILT_IN_NAME '(' Type OCOMMA_RPAREN
	{
		$$ = []PrimaryExpr{$1, "(", $3, $4} //TODO 107
	}
|	BUILT_IN_NAME '(' Type ',' ArgumentList OCOMMA_RPAREN
	{
		$$ = []PrimaryExpr{$1, "(", $3, ",", $5, $6} //TODO 108
	}
|	BUILT_IN_NAME '(' ArgumentList OCOMMA_RPAREN
	{
		$$ = []PrimaryExpr{$1, "(", $3, $4} //TODO 109
	}
|	PrimaryExpr '.' NON_TYPE_NAME
	{
		$$ = []PrimaryExpr{$1, ".", $3} //TODO 110
	}
|	PrimaryExpr '.' TYPE_NAME
	{
		$$ = []PrimaryExpr{$1, ".", $3} //TODO 111
	}
|	PrimaryExpr '[' Expression ']'
	{
		$$ = []PrimaryExpr{$1, "[", $3, "]"} //TODO 112
	}
|	PrimaryExpr '[' Slice1 ':' ']'
	{
		$$ = []PrimaryExpr{$1, "[", $3, ":", "]"} //TODO 113
	}
|	PrimaryExpr '[' Slice1 ':' Expression ']'
	{
		$$ = []PrimaryExpr{$1, "[", $3, ":", $5, "]"} //TODO 114
	}
|	PrimaryExpr '.' '(' Type ')'
	{
		$$ = []PrimaryExpr{$1, ".", "(", $4, ")"} //TODO 115
	}
|	PrimaryExpr '(' ')'
	{
		$$ = []PrimaryExpr{$1, "(", ")"} //TODO 116
	}
|	PrimaryExpr '(' ArgumentList OCOMMA_RPAREN
	{
		$$ = []PrimaryExpr{$1, "(", $3, $4} //TODO 117
	}

SelectStmt1:
	/* EMPTY */
	{
		$$ = []SelectStmt1(nil) //TODO 118
	}
|	SelectStmt1 CASE SendStmt ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, ":", $5) //TODO 119
	}
|	SelectStmt1 CASE Expression ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, ":", $5) //TODO 120
	}
|	SelectStmt1 CASE ExpressionList '=' Expression ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, "=", $5, ":", $7) //TODO 121
	}
|	SelectStmt1 CASE IDLIST_COLAS Expression ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "case", $3, $4, ":", $6) //TODO 122
	}
|	SelectStmt1 DEFAULT ':' StatementList
	{
		$$ = append($1.([]SelectStmt1), "default", ":", $4) //TODO 123
	}

SendStmt:
	Expression COMM Expression
	{
		$$ = []SendStmt{$1, $2, $3} //TODO 124
	}

Signature:
	Parameters %prec notLParen
	{
		$$ = $1 //TODO 125
	}
|	Parameters Parameters
	{
		$$ = []Signature{$1, $2} //TODO 126
	}
|	Parameters TypeName
	{
		$$ = []Signature{$1, $2} //TODO 127
	}
|	Parameters TypeLit
	{
		$$ = []Signature{$1, $2} //TODO 128
	}

SimpleStmt:
	/* EMPTY */
	{
		$$ = nil //TODO 129
	}
|	Expression
	{
		$$ = $1 //TODO 130
	}
|	SendStmt
	{
		$$ = $1 //TODO 131
	}
|	Expression INC
	{
		$$ = []SimpleStmt{$1, $2} //TODO 132
	}
|	Expression DEC
	{
		$$ = []SimpleStmt{$1, $2} //TODO 133
	}
|	ExpressionList ASSIGN_OP ExpressionList
	{
		$$ = []SimpleStmt{$1, $2, $3} //TODO 134
	}
|	IDLIST_COLAS ExpressionList
	{
		$$ = []SimpleStmt{$1, $2} //TODO 135
	}

Slice1:
	/* EMPTY */
	{
		$$ = nil //TODO 136
	}
|	Expression
	{
		$$ = $1 //TODO 137
	}

SliceType:
	'[' ']' ElementType
	{
		$$ = []SliceType{"[", "]", $3} //TODO 138
	}

SourceFile:
	PACKAGE NON_TYPE_NAME ';' SourceFile1 SourceFile2
	{
		$$ = []SourceFile{"package", $2, ";", $4, $5} //TODO 139
	}
|	PACKAGE TYPE_NAME ';' SourceFile1 SourceFile2
	{
		$$ = []SourceFile{"package", $2, ";", $4, $5} //TODO 140
	}

SourceFile1:
	/* EMPTY */
	{
		$$ = []SourceFile1(nil) //TODO 141
	}
|	SourceFile1 IMPORT ImportSpec ';'
	{
		$$ = append($1.([]SourceFile1), "import", $3, ";") //TODO 142
	}
|	SourceFile1 IMPORT '(' ImportDecl11 ')' ';'
	{
		$$ = append($1.([]SourceFile1), "import", "(", $4, ")", ";") //TODO 143
	}

SourceFile2:
	/* EMPTY */
	{
		$$ = []SourceFile2(nil) //TODO 144
	}
|	SourceFile2 Declaration ';'
	{
		$$ = append($1.([]SourceFile2), $2, ";") //TODO 145
	}
|	SourceFile2 FUNC NON_TYPE_NAME Function ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 146
	}
|	SourceFile2 FUNC TYPE_NAME Function ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 147
	}
|	SourceFile2 FUNC NON_TYPE_NAME Signature ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 148
	}
|	SourceFile2 FUNC TYPE_NAME Signature ';'
	{
		$$ = append($1.([]SourceFile2), "func", $3, $4, ";") //TODO 149
	}
|	SourceFile2 FUNC '(' TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, ")", $6, $7, ";") //TODO 150
	}
|	SourceFile2 FUNC '(' '*' TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", "*", $5, ")", $7, $8, ";") //TODO 151
	}
|	SourceFile2 FUNC '(' NON_TYPE_NAME TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, $5, ")", $7, $8, ";") //TODO 152
	}
|	SourceFile2 FUNC '(' NON_TYPE_NAME '*' TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, "*", $6, ")", $8, $9, ";") //TODO 153
	}
|	SourceFile2 FUNC '(' TYPE_NAME TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, $5, ")", $7, $8, ";") //TODO 154
	}
|	SourceFile2 FUNC '(' TYPE_NAME '*' TYPE_NAME ')' MethodName MethodDecl1 ';'
	{
		$$ = append($1.([]SourceFile2), "func", "(", $4, "*", $6, ")", $8, $9, ";") //TODO 155
	}

Start:
	SourceFile
	{
		_parserResult = $1 //TODO 156
	}

Statement:
	Declaration
	{
		$$ = $1 //TODO 157
	}
|	Label ':' Statement
	{
		$$ = []Statement{$1, ":", $3} //TODO 158
	}
|	SimpleStmt
	{
		$$ = $1 //TODO 159
	}
|	GO Expression
	{
		$$ = []Statement{"go", $2} //TODO 160
	}
|	RETURN
	{
		$$ = "return" //TODO 161
	}
|	RETURN ExpressionList
	{
		$$ = []Statement{"return", $2} //TODO 162
	}
|	BREAK
	{
		$$ = "break" //TODO 163
	}
|	BREAK Label
	{
		$$ = []Statement{"break", $2} //TODO 164
	}
|	CONTINUE
	{
		$$ = "continue" //TODO 165
	}
|	CONTINUE Label
	{
		$$ = []Statement{"continue", $2} //TODO 166
	}
|	GOTO Label
	{
		$$ = []Statement{"goto", $2} //TODO 167
	}
|	FALLTHROUGH
	{
		$$ = "fallthrough" //TODO 168
	}
|	Block
	{
		$$ = $1 //TODO 169
	}
|	IfStmt
	{
		$$ = $1 //TODO 170
	}
|	SWITCH ExprSwitchStmt2 '{' ExprSwitchStmt3 '}'
	{
		$$ = []Statement{"switch", $2, "{", $4, "}"} //TODO 171
	}
|	SWITCH SimpleStmt ';' ExprSwitchStmt2 '{' ExprSwitchStmt3 '}'
	{
		$$ = []Statement{"switch", $2, ";", $4, "{", $6, "}"} //TODO 172
	}
|	SWITCH PrimaryExpr '.' '(' TYPE ')' '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, ".", "(", "type", ")", "{", $8, "}"} //TODO 173
	}
|	SWITCH SimpleStmt ';' PrimaryExpr '.' '(' TYPE ')' '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, ";", $4, ".", "(", "type", ")", "{", $10, "}"} //TODO 174
	}
|	SWITCH IDLIST_COLAS PrimaryExpr '.' '(' TYPE ')' '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, $3, ".", "(", "type", ")", "{", $9, "}"} //TODO 175
	}
|	SWITCH SimpleStmt ';' IDLIST_COLAS PrimaryExpr '.' '(' TYPE ')' '{' TypeSwitchStmt2 '}'
	{
		$$ = []Statement{"switch", $2, ";", $4, $5, ".", "(", "type", ")", "{", $11, "}"} //TODO 176
	}
|	SELECT '{' SelectStmt1 '}'
	{
		$$ = []Statement{"select", "{", $3, "}"} //TODO 177
	}
|	FOR Block
	{
		$$ = []Statement{"for", $2} //TODO 178
	}
|	FOR Condition Block
	{
		$$ = []Statement{"for", $2, $3} //TODO 179
	}
|	FOR SimpleStmt ';' ';' SimpleStmt Block
	{
		$$ = []Statement{"for", $2, ";", ";", $5, $6} //TODO 180
	}
|	FOR SimpleStmt ';' Condition ';' SimpleStmt Block
	{
		$$ = []Statement{"for", $2, ";", $4, ";", $6, $7} //TODO 181
	}
|	FOR ExpressionList '=' RANGE Expression Block
	{
		$$ = []Statement{"for", $2, "=", "range", $5, $6} //TODO 182
	}
|	FOR IDLIST_COLAS RANGE Expression Block
	{
		$$ = []Statement{"for", $2, "range", $4, $5} //TODO 183
	}
|	DEFER Expression
	{
		$$ = []Statement{"defer", $2} //TODO 184
	}

StatementList:
	StatementList1
	{
		$$ = $1 //TODO 185
	}

StatementList1:
	/* EMPTY */
	{
		$$ = []StatementList1(nil) //TODO 186
	}
|	StatementList1 Statement ';'
	{
		$$ = append($1.([]StatementList1), $2, ";") //TODO 187
	}

StructType:
	STRUCT '{' StructType1 '}'
	{
		$$ = []StructType{"struct", "{", $3, "}"} //TODO 188
	}

StructType1:
	/* EMPTY */
	{
		$$ = []StructType1(nil) //TODO 189
	}
|	StructType1 IDENTIFIER_LIST Type FieldDecl2 ';'
	{
		$$ = append($1.([]StructType1), $2, $3, $4, ";") //TODO 190
	}
|	StructType1 TypeName FieldDecl2 ';'
	{
		$$ = append($1.([]StructType1), $2, $3, ";") //TODO 191
	}
|	StructType1 '*' TypeName FieldDecl2 ';'
	{
		$$ = append($1.([]StructType1), "*", $3, $4, ";") //TODO 192
	}

Type:
	TypeName %prec notRParen
	{
		$$ = $1 //TODO 193
	}
|	TypeLit
	{
		$$ = $1 //TODO 194
	}
|	'(' TypeName ')'
	{
		$$ = []Type{"(", $2, ")"} //TODO 195
	}
|	'(' TypeLit ')'
	{
		$$ = []Type{"(", $2, ")"} //TODO 196
	}

TypeDecl11:
	/* EMPTY */
	{
		$$ = []TypeDecl11(nil) //TODO 197
	}
|	TypeDecl11 TypeSpec ';'
	{
		$$ = append($1.([]TypeDecl11), $2, ";") //TODO 198
	}

TypeList1:
	/* EMPTY */
	{
		$$ = []TypeList1(nil) //TODO 199
	}
|	TypeList1 ',' Type
	{
		$$ = append($1.([]TypeList1), ",", $3) //TODO 200
	}

TypeLit:
	ArrayType
	{
		$$ = $1 //TODO 201
	}
|	StructType
	{
		$$ = $1 //TODO 202
	}
|	'*' Type
	{
		$$ = []TypeLit{"*", $2} //TODO 203
	}
|	FUNC Signature
	{
		$$ = []TypeLit{"func", $2} //TODO 204
	}
|	INTERFACE '{' InterfaceType1 '}'
	{
		$$ = []TypeLit{"interface", "{", $3, "}"} //TODO 205
	}
|	SliceType
	{
		$$ = $1 //TODO 206
	}
|	MapType
	{
		$$ = $1 //TODO 207
	}
|	CHAN ElementType
	{
		$$ = []TypeLit{"chan", $2} //TODO 208
	}
|	CHANCOMM ElementType
	{
		$$ = []TypeLit{$1, $2} //TODO 209
	}
|	COMMCHAN ElementType
	{
		$$ = []TypeLit{$1, $2} //TODO 210
	}

TypeName:
	TYPE_NAME
	{
		$$ = $1 //TODO 211
	}
|	PACK_NAME TYPE_NAME
	{
		$$ = []TypeName{$1, $2} //TODO 212
	}

TypeSpec:
	NON_TYPE_NAME Type
	{
		$$ = []TypeSpec{$1, $2} //TODO 213
	}
|	TYPE_NAME Type
	{
		$$ = []TypeSpec{$1, $2} //TODO 214
	}

TypeSwitchStmt2:
	/* EMPTY */
	{
		$$ = []TypeSwitchStmt2(nil) //TODO 215
	}
|	TypeSwitchStmt2 CASE Type TypeList1 ':' StatementList
	{
		$$ = append($1.([]TypeSwitchStmt2), "case", $3, $4, ":", $6) //TODO 216
	}
|	TypeSwitchStmt2 DEFAULT ':' StatementList
	{
		$$ = append($1.([]TypeSwitchStmt2), "default", ":", $4) //TODO 217
	}

UnaryExpr:
	PrimaryExpr
	{
		$$ = $1 //TODO 218
	}
|	'+' UnaryExpr
	{
		$$ = []UnaryExpr{"+", $2} //TODO 219
	}
|	'-' UnaryExpr
	{
		$$ = []UnaryExpr{"-", $2} //TODO 220
	}
|	'!' UnaryExpr
	{
		$$ = []UnaryExpr{"!", $2} //TODO 221
	}
|	'^' UnaryExpr
	{
		$$ = []UnaryExpr{"^", $2} //TODO 222
	}
|	'*' UnaryExpr
	{
		$$ = []UnaryExpr{"*", $2} //TODO 223
	}
|	'&' UnaryExpr
	{
		$$ = []UnaryExpr{"&", $2} //TODO 224
	}
|	COMM UnaryExpr
	{
		$$ = []UnaryExpr{$1, $2} //TODO 225
	}

VarDecl11:
	/* EMPTY */
	{
		$$ = []VarDecl11(nil) //TODO 226
	}
|	VarDecl11 VarSpec ';'
	{
		$$ = append($1.([]VarDecl11), $2, ";") //TODO 227
	}

VarSpec:
	IDENTIFIER_LIST Type
	{
		$$ = []VarSpec{$1, $2} //TODO 228
	}
|	IDENTIFIER_LIST Type '=' ExpressionList
	{
		$$ = []VarSpec{$1, $2, "=", $4} //TODO 229
	}
|	IDENTIFIER_LIST '=' ExpressionList
	{
		$$ = []VarSpec{$1, "=", $3} //TODO 230
	}

%%

//TODO remove demo stuff below

var _parserResult interface{}

type (
	ArgumentList interface{}
	ArrayType interface{}
	Block interface{}
	Condition interface{}
	ConstDecl11 interface{}
	ConstSpec interface{}
	Declaration interface{}
	Element interface{}
	ElementList1 interface{}
	ElementType interface{}
	ExprSwitchStmt2 interface{}
	ExprSwitchStmt3 interface{}
	Expression interface{}
	ExpressionList interface{}
	ExpressionList1 interface{}
	FieldDecl2 interface{}
	Function interface{}
	IfStmt interface{}
	IfStmt2 interface{}
	ImportDecl11 interface{}
	ImportPath interface{}
	ImportSpec interface{}
	InterfaceType1 interface{}
	Label interface{}
	LiteralValue interface{}
	MapType interface{}
	MethodDecl1 interface{}
	MethodName interface{}
	ParameterDecl interface{}
	ParameterDecl1 interface{}
	ParameterList1 interface{}
	Parameters interface{}
	PrimaryExpr interface{}
	SelectStmt1 interface{}
	SendStmt interface{}
	Signature interface{}
	SimpleStmt interface{}
	Slice1 interface{}
	SliceType interface{}
	SourceFile interface{}
	SourceFile1 interface{}
	SourceFile2 interface{}
	Start interface{}
	Statement interface{}
	StatementList interface{}
	StatementList1 interface{}
	StructType interface{}
	StructType1 interface{}
	Type interface{}
	TypeDecl11 interface{}
	TypeList1 interface{}
	TypeLit interface{}
	TypeName interface{}
	TypeSpec interface{}
	TypeSwitchStmt2 interface{}
	UnaryExpr interface{}
	VarDecl11 interface{}
	VarSpec interface{}
)
	
func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}
	
		fmt.Println(v)
	}
}

// End of demo stuff
